<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/polymer/lib/utils/flattened-nodes-observer.html">
<link rel="import" href="../../bower_components/paper-toggle-button/paper-toggle-button.html">
<link rel="import" href="../../bower_components/google-chart/google-chart.html">

<link rel="import" href="/src/typio-app/shared-styles.html">

<dom-module id="typio-code-editor">
  <template>
    <style include="shared-styles">

      :host {
        display: block;
      }

      /* Following style was inspired by https://typing.io/ */

      span {
        padding: .1em 0;
      }
      span.disabled {
        color: #737373 !important;
      }
      span.print-on-focus {
        visibility: hidden;
      }
      span.char-invalid.print-on-focus {
        visibility: visible !important;
      }
      span.char-active.print-on-focus {
        visibility: visible;
      }

      span.char-active {
        background-color: #47d42b;
        outline: 1px solid #40be27;
        color: #fff !important;
      }
      span.char-invalid {
        background-color: #e63d3d;
        outline: 1px solid #e63d3d;
        color: #fff !important;
      }
      span.char-active.paused {
        background-color: #ffc40d;
        outline: 1px solid #f3b700;
        color: #fff !important;
      }


      #content {
        width: 800px;
        margin: 0 auto;
        padding: 1cm;
      }


      #stats {
        position: fixed;
        top: 0;
        right: 0;
        padding: 1in;
        transition: width 0.5s, height 0.5s;
      }
      #stats .wpm {
        font-weight: bold;
        font-size: 2em;
      }

      #chart {
        height: 200px;
        width: 100%;
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
      }
    </style>


    <div id="controls">
      <paper-toggle-button checked="{{ignoreComments}}">Ignore comments?</paper-toggle-button>
      <paper-toggle-button checked="{{ignoreIndents}}">Ignore indents?</paper-toggle-button>
      <paper-toggle-button checked="{{continueOnErrors}}">Continue on errors?</paper-toggle-button>
    <div>
    <div id="stats">
      <template is="dom-if" if="{{!ended}}">
        <span class="wpm">[[_wpm]] WPM</span>
      </template>
      <template is="dom-if" if="{{ended}}">
        <table>
          <tbody>
            <tr><th>Typeable characters</th><td>[[_stats.typeableCharacters]]</td></tr>
            <tr><th>Typed characters</th><td>[[_stats.typedCharacters]]</td></tr>
            <tr><th>Unproductive keystroke overhead</th><td>[[_stats.unproductiveKeystrokeOverhead]]%</td></tr>
            <tr><th>Elasped time</th><td>[[_stats.elapsedTimeInS]]s</td></tr>
            <tr><th>WPM</th><td>[[_stats.wpm]]</td></tr>
          </tbody>
        </table>
      </template>
    </div>

    <div id="content">
      <pre id="editor2"></pre>
    </div>

    <div style="display: none">
    <slot id="editor">
<pre>public class HelloWorld {

    public static void main(String[] args) {
        // Prints "Hello, World" to the terminal window.
        System.out.println("Hello, World");
    }

}</pre>
    </slot>
    </div>

    <!-- See https://developers.google.com/chart/interactive/docs/gallery/steppedareachart -->
    <google-chart id="chart"
      type="stepped-area"
      options='{"title": "WPM", "legend": "none", "chartArea": { "left": 0, "top": 0, "width": "100%", "height": "100%"}, "hAxis": { "textPosition": "in", "textStyle": { "color": "rgba(0,0,0,0)" }  }, "vAxis": {"textPosition": "in", "minValue": 0, "maxValue": 200, "gridlines": { "count": 0 } } }'
      cols='[{"label": "Progress", "type": "string"},{"label": "WPM", "type": "number"}]'
      rows$='{{_wpmPerInterval}}'>
    </google-chart>

  </template>

  <script>
    /**
     * @customElement
     * @polymer
     */
    const GRAMMARS = {};


    class Stats {

      constructor() {
        this._totalCharacters = 0;
        this._enteredCharacters = 0;
        this._startTimestamp = null;
        this._endTimestamp = null;
        this._wpm = 0;
      }

      set totalCharacters(value) {
        this._totalCharacters = value;
      }

      get enteredCharacters() {
        return this._enteredCharacters;
      }

      get totalCharacters() {
        return this._totalCharacters;
      }

      startTimer() {
        this._startTimestamp = new Date();
      }

      newCharacter(character) {
        let timestamp = new Date();
        this._enteredCharacters++;
      }

      stopTimer() {
        this._endTimestamp = new Date();
      }

      resumeTimer() {
        if (!this._startTimestamp) {
          this.startTimer();
        }
      }

      /* Summary statistics */

      // Example of summary statistics:
      // - Typeable characters 690
      // - Typed characters 860
      // - Unproductive keystroke overhead 25%
      // - elasped time 4:06
      // - wpm 34  (Typeable characters / elasped time in minutes / 5)

      get typeableCharacters() {
        return this._totalCharacters;
      }

      get typedCharacters() {
        return this._enteredCharacters;
      }

      get unproductiveKeystrokeOverhead() {
        return Math.round(this.typedCharacters * 100 / this.typeableCharacters - 100, "%");
      }

      get elapsedTimeInS() {
        let end = this._endTimestamp;
        if (!end) {
          end = new Date();
        }
        return Math.round((end - this._startTimestamp) / 1000);
      }

      get wpm() {
        // see https://en.wikipedia.org/wiki/Words_per_minute for official definition
        return Math.round(this.typeableCharacters / this.elapsedTimeInS * 60.0 / 5);
      }

      // Current WPM value. Unlike wpm(), this method could be call anytime.
      currentWpm() {
        if (this._enteredCharacters < 10) {
          return 0;
        }
        return Math.round(this._enteredCharacters / this.elapsedTimeInS * 60.0 / 5);
      }

      progress(i) {
        return Math.round((i + 1) * 100 / this.totalCharacters);
      }

      progressInterval(i) {
        let p = this.progress(i);
        if (p < 5) return '0';
        if (p < 10) return '5';
        if (p < 15) return '10';
        if (p < 20) return '15';
        if (p < 25) return '20';
        if (p < 30) return '25';
        if (p < 35) return '30';
        if (p < 40) return '35';
        if (p < 45) return '40';
        if (p < 50) return '45';
        if (p < 55) return '50';
        if (p < 60) return '55';
        if (p < 65) return '60';
        if (p < 70) return '65';
        if (p < 75) return '70';
        if (p < 80) return '75';
        if (p < 85) return '80';
        if (p < 90) return '85';
        if (p < 95) return '90';
        if (p <= 100) return '95';
        return 0;
      }

    }

    class TypioCodeEditor extends Polymer.Element {

      static get is() { return 'typio-code-editor'; }
      static get properties() {
        return {

          /*
           * Programming language of the code snippet.
           *
           * Note: Case is not important.
           */
          language: {
            type: String,
            value: "Java"
          },

          /*
           * Should we exclude the comments present in the code snippet.
           */
          ignoreComments: {
            type: Boolean,
            value: true
          },

          /*
           * Should user enters indentation characters.
           */
          ignoreIndents: {
            type: Boolean,
            value: true
          },

          /*
           * Should we allow user to continue on mistyping.
           */
          continueOnErrors: {
            type: Boolean,
            value: false
          },

          paused: {
            type: Boolean,
            value: true
          },

          ended: {
            type: Boolean,
            value: false
          },

          // Collect statistics during edition
          _stats: {
            type: Object,
            value: new Stats()
          },

          // The list of <span class="character"> elements representing the characters to enter
          _characters: {
            type: Array,
            value: []
          },

          // The index of the current editable element
          _i: {
              type: Number,
              value: -1
          },

          // The index of the latest valid entered character
          _countValid: {
            type: Number,
            value: 0
          },

          // The currently estimated WPM
          _wpm: {
            type: Number,
            value: 0
          },

          // The WPM per time range
          _wpmPerInterval: {
            type: Array,
            value: [
              ["", undefined],
              ["", undefined],
              ["", undefined],
              ["", undefined],
              ["", undefined],
              ["", undefined],
              ["", undefined],
              ["", undefined],
              ["", undefined],
              ["", undefined],
              ["", undefined],
              ["", undefined],
              ["", undefined],
              ["", undefined],
              ["", undefined],
              ["", undefined],
              ["", undefined],
              ["", undefined],
              ["", undefined],
              ["", undefined]
            ]
          }

        };
      }

      static get observers() {
        return [
          // Observer method name, followed by a list of dependencies, in parenthesis
          '_refreshIgnorable(continueOnErrors, ignoreIndents)'
        ]
      }

      ready() {
        super.ready();

        // Watch for content update
        new Polymer.FlattenedNodesObserver(this, this._contentChanged);
        this.start();
      }

      start() {
        // We listen keyup for nonprintable characters
        document.addEventListener('keyup', (event) => {
          if (event.key === 'Backspace') {
            this.backward();
          }
        });

        // ... and keypress for printable ones (keypress support dead keys)
        document.addEventListener('keypress', (event) => {
          const keyName = event.key;
          const keyCode = event.code;

          if (keyName === 'Control') {
            // not alert when only Control key is pressed.
            return;
          }

          if (event.ctrlKey) {
            // Even though event.key is not 'Control' (i.e. 'a' is pressed),
            // event.ctrlKey may be true if Ctrl key is pressed at the time.
            ;
          } else {
            this.checkInput(event, keyName);
            event.preventDefault();
            return false;
          }

        }, false);
      }

      _contentChanged(nodes) {
        let { addedNodes, removedNodes } = nodes;
        this._updateContent();
      }

      _updateContent() {
        let preTags = this.$.editor.assignedNodes({ flatten: true }).filter(el => {
          return el.nodeType === Node.ELEMENT_NODE && el.nodeName === 'PRE';
        });
        if (preTags.length) {
          this._sourceTag = preTags[0];
          this._parse();
        }
      }

      _parse() {
        let newSourceCode = this._sourceTag.innerHTML;

        this._sourceCode = newSourceCode;
        this._length = this._sourceCode.length;
        this._determineTokens();

        let spaces = ' \t\n\r\v';

        let annotatedContent = '';

        // Step 2: Rebuild the content adding a <span> around each character
        // CSS classes are added to mark annotate the characters (space, variable, ...)
        let fragment = document.createDocumentFragment();
        let eol = false;

        let onlyIgnorableCharacters = true; // Does the current line contains only ignorable characters?
        for (let i = 0; i < this._length; i++) {
          let charTxt = this._sourceCode[i]; // The original character
          let charName = charTxt; // The name as returned by the keypress/keyup event (see key property)
          let charPrint = charTxt; // The character print on screen

          let charCode = this._sourceCode.charCodeAt(i);
          let classes = [];

          let span = document.createElement('span');
          span.classList.add('character');
          span.classList.add('disabled');

          if (charTxt == '\n') {
            // Put Unicode return symbol as content &#9166; (should be displayed only when actived)
            charName = 'Enter';
            charPrint = ' <strong>&#9166;</strong> \n';
            span.classList.add('print-on-focus');
            span.classList.add('backslash');
            if (onlyIgnorableCharacters) {
              span.classList.add('ignorable');
            }
            eol = true;
            onlyIgnorableCharacters = true;
          } else {

            let iSpace = spaces.indexOf(charTxt);
            if (iSpace !== -1) {
              span.classList.add('space');
              if (eol) {
                span.classList.add('indent');
              }
            } else {
              span.classList.add('letter');
              eol = false;
            }
            if (this._tokens[i]) {
              let token = this._tokens[i];
              span.classList.add('token');
              span.classList.add(token);
              if (!this.ignoreComments || token != "comment") {
                onlyIgnorableCharacters = false;
              }
            }
          }

          span.dataset.text = charName;
          span.innerHTML = charPrint;
          fragment.appendChild(span);
        }
        this.$.editor2.appendChild(fragment);

        this._characters = this.$.editor2.querySelectorAll('.character');
        this._stats.totalCharacters = this.enterableCharacters();
        this.advance();
      }

      _refreshIgnorable() {
        // TODO When the user toggle switches, we should update the 'ignorable' CSS class
      }

      _determineTokens() {
        this._tokens = new Array(this._length);

        let grammar = GRAMMARS[this.language.toLowerCase()];
        for (let token in grammar) {
          if (!grammar.hasOwnProperty(token) || !grammar[token]) {
            continue;
          }

          let pattern = grammar[token];
          let lookbehind = !!pattern.lookbehind;
          let lookbehindLength = 0;

          pattern = pattern.pattern || pattern;
          let flags = pattern.flags || '';
          if (flags.indexOf('g') === -1) {
            flags += 'g';
          }
          pattern = new RegExp(pattern, flags);
          let match;
          while (match = pattern.exec(this._sourceCode)) {
            if (lookbehind) {
              lookbehindLength = match[1].length;
            }
            let start = match.index + lookbehindLength;
            match = match[0].slice(lookbehindLength);
            let len = match.length;
            let end = start + len;

            for (let i = start; i < start + len; i++) {
              if (!this._tokens[i]) {
                this._tokens[i] = token;
              }
            }
          }
        }
      }

      enterableCharacters() {
        return this.$.editor2.querySelectorAll('.character').length -
               (this.ignoreComments ? this.$.editor2.querySelectorAll('.comment').length : 0) -
               (this.ignoreIndents ? this.$.editor2.querySelectorAll('.indent').length : 0) - 1;
      }

      resume() {
        this.paused = false;
        this._stats.resumeTimer();
      }

      checkInput(event, keyName) {
        if (this.paused) {
          this.resume();
        }

        let character = this._cursor();
        this._stats.newCharacter();
        this._wpm = this._stats.currentWpm();

        let progressInterval = this._stats.progressInterval(this._countValid);
        let indexInterval = parseInt(parseInt(progressInterval) / 5);
        console.log('>', indexInterval, this._wpm, this._wpmPerInterval[indexInterval][1]);
        this._wpmPerInterval[indexInterval][0] = '' + this._wpm; // Label
        this._wpmPerInterval[indexInterval][1] = this._wpm; // Value
        this.$.chart.rows = this._wpmPerInterval.slice(0);
        this.$.chart.redraw();

        if (character.dataset.text == keyName) {
          character.classList.remove('disabled');
          if (this.continueOnErrors) {
            character.classList.remove('char-invalid');
          } else if (this._error && !this.continueOnErrors) {
            character.classList.add('char-invalid');
          }
          if (!this._error) {
            this._countValid++;
          }
          this.advance();
        } else {
          character.classList.add('char-invalid');
          this._error = true;
          this._iError = this._i;
          this.$.editor2.classList.add('error');
          this.advance();
        }
      }

      backward() {
        if (this._i == 0) return; // Do nothing if at start

        do {
          this._unhighlight();
          this._i--;

          if (this._error && this._i === this._iError) {
            this._error = false;
            this.$.editor2.classList.remove('error');
          }
        } while (this._isIgnorable());

        if (this._i >=0) {
          this._highlight();
        }
      }

      advance() {
        if (this._i >=0) {
          this._cursor().classList.remove('char-active');
        }
        if (this._isEndOfFile()) {
          // Do not trigger end if there is error, except if allowed
          if (this._allowToEnd()) {
            this.end();
          }
          return;
        }
        this._i++;
        while (!this._isEndOfFile() && this._isIgnorable()) { this._i++ }
        this._highlight();
      }

      _allowToEnd() {
        return this._error == false || this.continueOnErrors;
      }

      end() {
        this._stats.stopTimer();
        this.ended = true;
        this.dispatchEvent(new CustomEvent('endOfInput', {detail: {length: this._length}}));
      }


      // Utility methods to manipulate current character

      _cursor() {
        return this._characters[this._i];
      }

      _isIgnorable() {
        let character = this._cursor();
        if (this.ignoreComments && character.classList.contains('comment')) {
          return true;
        }
        if (this.ignoreIndents && character.classList.contains('indent')) {
          return true;
        }
        if (character.classList.contains('ignorable')) { // special marker
          return true;
        }
        return false;
      }

      _isEndOfFile() {
        return this._i + 1 >= this._length;
      }

      _highlight() {
        let character = this._cursor();
        character.classList.remove('char-invalid');
        character.classList.add('char-active');
        character.classList.add('disabled');
      }

      _unhighlight() {
        let character = this._cursor();
        character.classList.remove('char-active');
        character.classList.remove('char-invalid');
        character.classList.add('disabled');
      }

    }
    window.customElements.define(TypioCodeEditor.is, TypioCodeEditor);


    // ////////////////////
    // Language definitions
    ///////////////////////

    const basic = {
      'string': /"(?:""|[!#$%&'()*,\/:;<=>?^_ +\-.A-Z\d])*"/i,
      'comment': {
        pattern: /(?:!|REM\b).+/i,
        inside: {
          'keyword': /^REM/i
        }
      },
      'number': /(?:\b|\B[.-])(?:\d+\.?\d*)(?:E[+-]?\d+)?/i,
      'keyword': /\b(?:AS|BEEP|BLOAD|BSAVE|CALL(?: ABSOLUTE)?|CASE|CHAIN|CHDIR|CLEAR|CLOSE|CLS|COM|COMMON|CONST|DATA|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DIM|DO|DOUBLE|ELSE|ELSEIF|END|ENVIRON|ERASE|ERROR|EXIT|FIELD|FILES|FOR|FUNCTION|GET|GOSUB|GOTO|IF|INPUT|INTEGER|IOCTL|KEY|KILL|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|MKDIR|NAME|NEXT|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPTION BASE|OUT|POKE|PUT|READ|REDIM|REM|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SHARED|SINGLE|SELECT CASE|SHELL|SLEEP|STATIC|STEP|STOP|STRING|SUB|SWAP|SYSTEM|THEN|TIMER|TO|TROFF|TRON|TYPE|UNLOCK|UNTIL|USING|VIEW PRINT|WAIT|WEND|WHILE|WRITE)(?:\$|\b)/i,
      'function': /\b(?:ABS|ACCESS|ACOS|ANGLE|AREA|ARITHMETIC|ARRAY|ASIN|ASK|AT|ATN|BASE|BEGIN|BREAK|CAUSE|CEIL|CHR|CLIP|COLLATE|COLOR|CON|COS|COSH|COT|CSC|DATE|DATUM|DEBUG|DECIMAL|DEF|DEG|DEGREES|DELETE|DET|DEVICE|DISPLAY|DOT|ELAPSED|EPS|ERASABLE|EXLINE|EXP|EXTERNAL|EXTYPE|FILETYPE|FIXED|FP|GO|GRAPH|HANDLER|IDN|IMAGE|IN|INT|INTERNAL|IP|IS|KEYED|LBOUND|LCASE|LEFT|LEN|LENGTH|LET|LINE|LINES|LOG|LOG10|LOG2|LTRIM|MARGIN|MAT|MAX|MAXNUM|MID|MIN|MISSING|MOD|NATIVE|NUL|NUMERIC|OF|OPTION|ORD|ORGANIZATION|OUTIN|OUTPUT|PI|POINT|POINTER|POINTS|POS|PRINT|PROGRAM|PROMPT|RAD|RADIANS|RANDOMIZE|RECORD|RECSIZE|RECTYPE|RELATIVE|REMAINDER|REPEAT|REST|RETRY|REWRITE|RIGHT|RND|ROUND|RTRIM|SAME|SEC|SELECT|SEQUENTIAL|SET|SETTER|SGN|SIN|SINH|SIZE|SKIP|SQR|STANDARD|STATUS|STR|STREAM|STYLE|TAB|TAN|TANH|TEMPLATE|TEXT|THERE|TIME|TIMEOUT|TRACE|TRANSFORM|TRUNCATE|UBOUND|UCASE|USE|VAL|VARIABLE|VIEWPORT|WHEN|WINDOW|WITH|ZER|ZONEWIDTH)(?:\$|\b)/i,
      'operator': /<[=>]?|>=?|[+\-*\/^=&]|\b(?:AND|EQV|IMP|NOT|OR|XOR)\b/i,
      'punctuation': /[,;:()]/
    };

    const clike = {
      'comment': [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
          lookbehind: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true
        }
      ],
      'string': {
        pattern: /(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      'class-name': {
        pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,
        lookbehind: true,
        inside: {
          punctuation: /(\.|\\)/
        }
      },
      'keyword': /\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
      'boolean': /\b(true|false)\b/,
      'function': /[a-z0-9_]+(?=\()/i,
      'number': /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,
      'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
      'punctuation': /[{}[\];(),.:]/
    };

    const java = Object.assign({}, basic, clike, {
      'keyword': /\b(abstract|continue|for|new|switch|assert|default|goto|package|synchronized|boolean|do|if|private|this|break|double|implements|protected|throw|byte|else|import|public|throws|case|enum|instanceof|return|transient|catch|extends|int|short|try|char|final|interface|static|void|class|finally|long|strictfp|volatile|const|float|native|super|while)\b/,
      'number': /\b0b[01]+\b|\b0x[\da-f]*\.?[\da-fp\-]+\b|\b\d*\.?\d+(?:e[+-]?\d+)?[df]?\b/i,
      'operator': {
        pattern: /(^|[^.])(?:\+[+=]?|-[-=]?|!=?|<<?=?|>>?>?=?|==?|&[&=]?|\|[|=]?|\*=?|\/=?|%=?|\^=?|[?:~])/m,
        lookbehind: true
      }
    });

    const python = {
      'triple-quoted-string': {
        pattern: /"""[\s\S]+?"""|'''[\s\S]+?'''/,
        alias: 'string'
      },
      'comment': {
        pattern: /(^|[^\\])#.*/,
        lookbehind: true
      },
      'string': {
        pattern: /("|')(?:\\\\|\\?[^\\\r\n])*?\1/,
        greedy: true
      },
      'function' : {
        pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_][a-zA-Z0-9_]*(?=\()/g,
        lookbehind: true
      },
      'class-name': {
        pattern: /(\bclass\s+)[a-z0-9_]+/i,
        lookbehind: true
      },
      'keyword' : /\b(?:as|assert|async|await|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|pass|print|raise|return|try|while|with|yield)\b/,
      'boolean' : /\b(?:True|False)\b/,
      'number' : /\b-?(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*\.?\d*|\.\d+)(?:e[+-]?\d+)?j?\b/i,
      'operator' : /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]|\b(?:or|and|not)\b/,
      'punctuation' : /[{}[\];(),.:]/
    };

    // Register grammars here
    GRAMMARS['java'] = java;
    GRAMMARS['python'] = python;
    // to complete...


  </script>
</dom-module>
