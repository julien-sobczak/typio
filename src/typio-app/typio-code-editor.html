<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/polymer/lib/utils/flattened-nodes-observer.html">
<link rel="import" href="../../bower_components/paper-toggle-button/paper-toggle-button.html">

<link rel="import" href="/src/typio-app/shared-styles.html">

<dom-module id="typio-code-editor">
  <template>
    <style include="shared-styles">

      :host {
        display: block;
      }

      /* Following style was inspired by https://typing.io/ */

      span {
        padding: .1em 0;
      }
      span.disabled {
        color: #737373 !important;
      }
      span.print-on-focus {
        visibility: hidden;
      }
      span.char-invalid.print-on-focus {
        visibility: visible !important;
      }
      span.char-active.print-on-focus {
        visibility: visible;
      }

      span.char-active {
        background-color: #47d42b;
        outline: 1px solid #40be27;
        color: #fff !important;
      }
      #editor2.error span.char-active {
        background-color: #e63d3d;
        outline: 1px solid #e63d3d;
        color: #fff !important;
      }
      span.char-invalid {
        background-color: #e63d3d;
        outline: 1px solid #e63d3d;
        color: #fff !important;
      }
      span.char-active.paused {
        background-color: #ffc40d;
        outline: 1px solid #f3b700;
        color: #fff !important;
      }


      #content {
        width: 800px;
        margin: 0 auto;
        padding: 1cm;
      }

    </style>


    <div id="controls">
      <paper-toggle-button checked="{{ignoreComments}}">Ignore comments?</paper-toggle-button>
      <paper-toggle-button checked="{{ignoreIndents}}">Ignore indents?</paper-toggle-button>
      <paper-toggle-button checked="{{continueOnErrors}}">Continue on errors?</paper-toggle-button>
    <div>
    <div id="content">
      <pre id="editor2"></pre>
    </div>

    <div style="display: none">
    <slot id="editor">
<pre>public class HelloWorld {

    public static void main(String[] args) {
        // Prints "Hello, World" to the terminal window.
        System.out.println("Hello, World");
    }

}</pre>
    </slot>
    </div>

  </template>

  <script>
    /**
     * @customElement
     * @polymer
     */
    const GRAMMARS = {};

    class TypioCodeEditor extends Polymer.Element {

      static get is() { return 'typio-code-editor'; }
      static get properties() {
        return {

          /*
           * Programming language of the code snippet.
           *
           * Note: Case is not important.
           */
          language: {
            type: String,
            value: "Java"
          },

          /*
           * Should we exclude the comments present in the code snippet.
           */
          ignoreComments: {
            type: Boolean,
            value: true
          },

          /*
           * Should user enters indentation characters.
           */
          ignoreIndents: {
            type: Boolean,
            value: true
          },

          /*
           * Should we allow user to continue on mistyping.
           */
          continueOnErrors: {
            type: Boolean,
            value: false
          },

          // The list of <span class="editable"> elements representing the characters to enter
          _characters: {
            type: Array,
            value: []
          },

          // The index of the current editable element
          _i: {
              type: Number,
              value: -1
          }
        };
      }

      ready() {
        super.ready();
        new Polymer.FlattenedNodesObserver(this, this._contentChanged);
        this.start();
      }

      start() {
        document.addEventListener('keyup', (event) => {
          if (event.key === 'Backspace') {
            this.backward();
          }
        });

        document.addEventListener('keypress', (event) => {
          const keyName = event.key;
          const keyCode = event.code;

          if (keyName === 'Control') {
            // not alert when only Control key is pressed.
            return;
          }

          if (event.ctrlKey) {
            // Even though event.key is not 'Control' (i.e. 'a' is pressed),
            // event.ctrlKey may be true if Ctrl key is pressed at the time.
            ;
          } else {
            this.checkInput(event, keyName);
            event.preventDefault();
            return false;
          }

        }, false);
      }

      _contentChanged(nodes) {
        let { addedNodes, removedNodes } = nodes;
        this._updateContent();
      }

      _updateContent() {
        let preTags = this.$.editor.assignedNodes({ flatten: true }).filter(el => {
          return el.nodeType === Node.ELEMENT_NODE && el.nodeName === 'PRE';
        });
        if (preTags.length) {
          this._sourceTag = preTags[0];
          this._parse();
        }
      }

      _parse() {
        let newSourceCode = this._sourceTag.innerHTML;

        this._raw = newSourceCode;
        this._sourceCode = newSourceCode;
        this._tokens = new Array(this._raw.length);

        let spaces = ' \t\n\r\v';
        let spacesText = [' ', '\\t', '\\n', '\\r', '\\v'];

        let annotatedContent = '';


        let grammar = GRAMMARS[this.language.toLowerCase()];

        for (let token in grammar) {
          if (!grammar.hasOwnProperty(token) || !grammar[token]) {
            continue;
          }

          let pattern = grammar[token];
          let lookbehind = !!pattern.lookbehind;
          let lookbehindLength = 0;

          pattern = pattern.pattern || pattern;
          let flags = pattern.flags || '';
          if (flags.indexOf('g') === -1) {
            flags += 'g';
          }
          pattern = new RegExp(pattern, flags);
          let match;
          while (match = pattern.exec(this._sourceCode)) {
            if (lookbehind) {
              lookbehindLength = match[1].length;
            }
            let start = match.index + lookbehindLength;
            match = match[0].slice(lookbehindLength);
            let len = match.length;
            let end = start + len;

            for (let i = start; i < start + len; i++) {
              if (!this._tokens[i]) {
                this._tokens[i] = token;
              }
            }

            //console.log(token, match, start, len);
          }

        }


        let fragment = document.createDocumentFragment();
        let eol = false;
        this._length = newSourceCode.length;
        for (let i = 0; i < this._length; i++) {
          let charTxt = newSourceCode[i]; // The original character
          let charName = charTxt; // The name as returned by the keypress/keyup event (see key property)
          let charPrint = charTxt; // The character print on screen

          let charPrintableTxt = newSourceCode[i];
          let charCode = newSourceCode.charCodeAt(i);
          let classes = [];

          let span = document.createElement('span');
          span.classList.add('editable');
          span.classList.add('disabled');

          if (charTxt == '\n') {
            // Put Unicode return symbol as content &#9166; (should be displayed only when actived)
            charName = 'Enter';
            charPrint = ' <strong>&#9166;</strong> \n';
            span.classList.add('print-on-focus');
            eol = true;
          }

          let iSpace = spaces.indexOf(charTxt);
          if (iSpace !== -1) {
            charPrintableTxt = spacesText[iSpace];
            span.classList.add('space');
            if (eol) {
              span.classList.add('indent');
            }
          } else {
            span.classList.add('letter');
            eol = false;
          }
          if (this._tokens[i]) {
            span.classList.add('token');
            span.classList.add(this._tokens[i]);
          }

          span.dataset.text = charName;
          span.innerHTML = charPrint;
          fragment.appendChild(span);
        }
        this.$.editor2.appendChild(fragment);

        this._characters = this.$.editor2.querySelectorAll('.editable');
        this.advanceNextInput();

      }

      checkInput(event, keyName) {
        if (this._characters[this._i].dataset.text == keyName) {
          this._characters[this._i].classList.remove('disabled');
          this._characters[this._i].classList.remove('char-invalid');
          this.advanceNextInput();
        } else {
          this._characters[this._i].classList.add('char-invalid');
          this._error = true;
          this._iError = this._i;
          this.$.editor2.classList.add('error');
          this.advanceNextInput();
        }
      }

      backward() {
        do {
          this._unhighlight();
          this._i--;

          if (this._error && this._i === this._iError) {
            this._error = false;
            this.$.editor2.classList.remove('error');
          }
        } while (this._isIgnorable());

        if (this._i >=0) {
          this._highlight();
        }
      }

      advanceNextInput() {
        if (this._i >=0) {
          this._cursor().classList.remove('char-active');
        }
        this._i++;
        while (this._isIgnorable()) { this._i++ }
        if (this._isEndOfFile()) {
          this.dispatchEvent(new CustomEvent('endOfInput', {detail: {length: this._length}}));
          return;
        }
        this._highlight();
      }

      // Utility methods to manipulate current character

      _cursor() {
        return this._characters[this._i];
      }

      _isIgnorable() {
        let character = this._cursor();
        if (this.ignoreComments && character.classList.contains('comment')) {
          return true;
        }
        if (this.ignoreIndents && character.classList.contains('indent')) {
          return true;
        }
        return false;
      }

      _isEndOfFile() {
        return this._i + 1 >= this._length;
      }

      _highlight() {
        let character = this._cursor();
        character.classList.remove('char-invalid');
        character.classList.add('char-active');
        character.classList.add('disabled');
      }

      _unhighlight() {
        let character = this._cursor();
        character.classList.remove('char-active');
        character.classList.remove('char-invalid');
        character.classList.add('disabled');
      }

    }
    window.customElements.define(TypioCodeEditor.is, TypioCodeEditor);


    // ////////////////////
    // Language definitions
    ///////////////////////

    const basic = {
      'string': /"(?:""|[!#$%&'()*,\/:;<=>?^_ +\-.A-Z\d])*"/i,
      'comment': {
        pattern: /(?:!|REM\b).+/i,
        inside: {
          'keyword': /^REM/i
        }
      },
      'number': /(?:\b|\B[.-])(?:\d+\.?\d*)(?:E[+-]?\d+)?/i,
      'keyword': /\b(?:AS|BEEP|BLOAD|BSAVE|CALL(?: ABSOLUTE)?|CASE|CHAIN|CHDIR|CLEAR|CLOSE|CLS|COM|COMMON|CONST|DATA|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DIM|DO|DOUBLE|ELSE|ELSEIF|END|ENVIRON|ERASE|ERROR|EXIT|FIELD|FILES|FOR|FUNCTION|GET|GOSUB|GOTO|IF|INPUT|INTEGER|IOCTL|KEY|KILL|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|MKDIR|NAME|NEXT|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPTION BASE|OUT|POKE|PUT|READ|REDIM|REM|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SHARED|SINGLE|SELECT CASE|SHELL|SLEEP|STATIC|STEP|STOP|STRING|SUB|SWAP|SYSTEM|THEN|TIMER|TO|TROFF|TRON|TYPE|UNLOCK|UNTIL|USING|VIEW PRINT|WAIT|WEND|WHILE|WRITE)(?:\$|\b)/i,
      'function': /\b(?:ABS|ACCESS|ACOS|ANGLE|AREA|ARITHMETIC|ARRAY|ASIN|ASK|AT|ATN|BASE|BEGIN|BREAK|CAUSE|CEIL|CHR|CLIP|COLLATE|COLOR|CON|COS|COSH|COT|CSC|DATE|DATUM|DEBUG|DECIMAL|DEF|DEG|DEGREES|DELETE|DET|DEVICE|DISPLAY|DOT|ELAPSED|EPS|ERASABLE|EXLINE|EXP|EXTERNAL|EXTYPE|FILETYPE|FIXED|FP|GO|GRAPH|HANDLER|IDN|IMAGE|IN|INT|INTERNAL|IP|IS|KEYED|LBOUND|LCASE|LEFT|LEN|LENGTH|LET|LINE|LINES|LOG|LOG10|LOG2|LTRIM|MARGIN|MAT|MAX|MAXNUM|MID|MIN|MISSING|MOD|NATIVE|NUL|NUMERIC|OF|OPTION|ORD|ORGANIZATION|OUTIN|OUTPUT|PI|POINT|POINTER|POINTS|POS|PRINT|PROGRAM|PROMPT|RAD|RADIANS|RANDOMIZE|RECORD|RECSIZE|RECTYPE|RELATIVE|REMAINDER|REPEAT|REST|RETRY|REWRITE|RIGHT|RND|ROUND|RTRIM|SAME|SEC|SELECT|SEQUENTIAL|SET|SETTER|SGN|SIN|SINH|SIZE|SKIP|SQR|STANDARD|STATUS|STR|STREAM|STYLE|TAB|TAN|TANH|TEMPLATE|TEXT|THERE|TIME|TIMEOUT|TRACE|TRANSFORM|TRUNCATE|UBOUND|UCASE|USE|VAL|VARIABLE|VIEWPORT|WHEN|WINDOW|WITH|ZER|ZONEWIDTH)(?:\$|\b)/i,
      'operator': /<[=>]?|>=?|[+\-*\/^=&]|\b(?:AND|EQV|IMP|NOT|OR|XOR)\b/i,
      'punctuation': /[,;:()]/
    };

    const clike = {
      'comment': [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
          lookbehind: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true
        }
      ],
      'string': {
        pattern: /(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      'class-name': {
        pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,
        lookbehind: true,
        inside: {
          punctuation: /(\.|\\)/
        }
      },
      'keyword': /\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
      'boolean': /\b(true|false)\b/,
      'function': /[a-z0-9_]+(?=\()/i,
      'number': /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,
      'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
      'punctuation': /[{}[\];(),.:]/
    };

    const java = Object.assign({}, basic, clike, {
      'keyword': /\b(abstract|continue|for|new|switch|assert|default|goto|package|synchronized|boolean|do|if|private|this|break|double|implements|protected|throw|byte|else|import|public|throws|case|enum|instanceof|return|transient|catch|extends|int|short|try|char|final|interface|static|void|class|finally|long|strictfp|volatile|const|float|native|super|while)\b/,
      'number': /\b0b[01]+\b|\b0x[\da-f]*\.?[\da-fp\-]+\b|\b\d*\.?\d+(?:e[+-]?\d+)?[df]?\b/i,
      'operator': {
        pattern: /(^|[^.])(?:\+[+=]?|-[-=]?|!=?|<<?=?|>>?>?=?|==?|&[&=]?|\|[|=]?|\*=?|\/=?|%=?|\^=?|[?:~])/m,
        lookbehind: true
      }
    });

    const python = {
      'triple-quoted-string': {
        pattern: /"""[\s\S]+?"""|'''[\s\S]+?'''/,
        alias: 'string'
      },
      'comment': {
        pattern: /(^|[^\\])#.*/,
        lookbehind: true
      },
      'string': {
        pattern: /("|')(?:\\\\|\\?[^\\\r\n])*?\1/,
        greedy: true
      },
      'function' : {
        pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_][a-zA-Z0-9_]*(?=\()/g,
        lookbehind: true
      },
      'class-name': {
        pattern: /(\bclass\s+)[a-z0-9_]+/i,
        lookbehind: true
      },
      'keyword' : /\b(?:as|assert|async|await|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|pass|print|raise|return|try|while|with|yield)\b/,
      'boolean' : /\b(?:True|False)\b/,
      'number' : /\b-?(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*\.?\d*|\.\d+)(?:e[+-]?\d+)?j?\b/i,
      'operator' : /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]|\b(?:or|and|not)\b/,
      'punctuation' : /[{}[\];(),.:]/
    };

    // Register grammars here
    GRAMMARS['java'] = java;
    GRAMMARS['python'] = python;
    // to complete...


  </script>
</dom-module>
