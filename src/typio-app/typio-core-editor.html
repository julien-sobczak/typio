<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/polymer/lib/utils/flattened-nodes-observer.html">
<link rel="import" href="/src/typio-app/shared-styles.html">

<dom-module id="typio-core-editor">
  <template>

    <!-- Stylesheet will be switched according the theme -->
    <link id="prismStylesheet" href="/css/prism-light.css" href$="/css/prism-{{theme}}.css" rel="stylesheet">

    <style include="shared-styles">

      :host {
        display: block;
        width: 1000px;
        margin: 0 auto;
        padding: 1cm;
        position: fixed;
        top: 64px;
        bottom: 50px;
        z-index: 40;
        left: 50%;
        margin-left: -500px; /* Half of the width */

        overflow-y: hidden;
        overflow-x: visible;
      }
      
      #content.initialized-false {
        display: none;
      }
      #content.initialized-true {
        display: block;
      }
      
      /*
       * Type support
       */
      
      pre[data-type="literature"] {
        font-family: 'Droid Sans Mono', monospace;
      }
      pre[data-type="code"] {
        font-family: monospace;
      }
      pre.preserveSpacing-false {
        white-space: normal; /* Disable pre default behavior*/
      }
      pre.fontSize-large span {
        font-size: 150%;
        letter-spacing: 3px;
        line-height: 2;
        outline: none !important; 
      }


      /* Following style was inspired by https://typing.io/ */

      span {
        padding: .1em 0;
      }
      span.disabled {
        color: #737373 !important;
      }
      span.print-on-focus {
        visibility: hidden;
      }
      span.continuation {
        display: inline-block;
        width: 1em;
      }
      span.char-invalid.print-on-focus {
        visibility: visible !important;
      }
      span.char-active.print-on-focus {
        visibility: visible;
      }

      /* We need !important to override special code
      such as operator, comment that also define a background. */
      span.char-active {
        background-color: #47d42b !important;
        outline: 1px solid #40be27 !important;
        color: #fff !important;
      }
      span.char-invalid {
        background-color: #e63d3d !important;
        outline: none !important;
        color: #fff !important;
      }
      span.char-active.paused {
        background-color: #ffc40d !important;
        outline: 1px solid #f3b700 !important;
        color: #fff !important;
      }

      .highlight-mistyping span.useless {
        background-color: #faa937;
        outline: 1px solid #faa937;
        color: #fff !important;
      }
      .highlight-mistyping span.wrong {
        background-color: #d51b1b;
        outline: 1px solid #d51b1b;
        color: #fff !important;
      }

      #content {
        height: 100%;
      }
      #editor {
        height: 100%;
        color: black;
      }

      /* Theme management */
      #content.theme-dark {
        background: #272822;
        color: white;
      }

      /* Show a gradient at the bottom to show there is text that follows. */
      #content.mode-scroll:after {
        content: '';
        width: 100%;
        height: 100%;
        position: absolute;
        z-index: 500;
        left: 0;
        bottom: 0;
      }
      #content.mode-scroll.theme-light:after {
        background: linear-gradient(transparent 90%, white);
      }
      #content.mode-scroll.theme-dark:after {
        background: linear-gradient(transparent 90%, #272822);
      }

      #content.ended-true #content {
        bottom: 0 !important;
      }

      #editor {
        line-height: 1.5em;
        height: 100%;
        transition: margin 300ms; /* Used in Scroll Mode */
      }

      #content.theme-light #editor {
        color: black;
      }
      #content.theme-dark #editor {
        color: white;
      }


      /* Highlight intervals using a CSS class. */

      .highlight-interval-0 span.interval-0,
      .highlight-interval-1 span.interval-1,
      .highlight-interval-2 span.interval-2,
      .highlight-interval-3 span.interval-3,
      .highlight-interval-4 span.interval-4,
      .highlight-interval-5 span.interval-5,
      .highlight-interval-6 span.interval-6,
      .highlight-interval-7 span.interval-7,
      .highlight-interval-8 span.interval-8,
      .highlight-interval-9 span.interval-9,
      .highlight-interval-10 span.interval-10 {
        background-color: Gold !important;
        outline: none !important;
        color: black !important;
      }
      
    </style>


    <div id="content" class$="type-[[type]] initialized-[[initialized]] started-[[started]] mode-{{mode}} ended-{{ended}} theme-[[theme]]">
      <pre id="editor" data-type$="[[type]]" class$="preserveSpacing-[[preserveSpacing]] fontSize-[[fontSize]]">[[_content]]</pre>
    </div>      
      
  </template>

  <script>

    /**
     * Editor screen (where text to type is displayed).
     *
     * @customElement
     * @polymer
     */
    class TypioCoreEditor extends Polymer.Element {

      static get is() { return 'typio-core-editor'; }
      static get properties() {
        return {

          // 
          // User input properties
          //

          /**
           * The type of content (code, literature).
           */
          type: {
            type: String,
            value: "code"
          },
          
          /**
           * The content to touch type. (required)
           *
           * This property should be set in JavaScript and
           * not through an HTML attribute to avoid HTML escaping (&lt; for <).
           */
          content: {
            type: String,
            value: 'import sys\n\ndef main():\n  print("Hello World")\n  sys.exit(0)\n',
            observer: '_contentChanged'
          },
          
          /**
           * Editor code style.
           * Name should match a CSS resource name /css/prism-{{theme}}.css.
           */
          theme: {
            type: String,
            value: 'light'
          },
          
          /**
           * The mode to use when text to type exceed the size of the window.
           *
           * Possible values: 'scroll', 'page'.
           */
          mode: {
            type: String,
            value: 'scroll',
          },
          
          /**
           * Additional CSS classes to append to each character.
           * The array should have the same size as the property `content`. 
           */
          classes: {
            type: Array,
            value: undefined
          },
          
          // TODO merge into classes directly and offer method 'un/highlight(classes...)'
          intervals: {
            type: Array,
            value: []
          },     
          // TODO same for logicalLines => TypioParser could split long lines and add
          // a special CSS class on continuation line.    

          /**
           * Let the user continues typing when an error occurs.
           * If false, the session will not end until all characters are valid.
           */
          continueOnErrors: {
            type: Boolean,
            value: false
          },
          

          //
          // Developer options
          //

          /**
           * Log debug information to the console.
           */
          debug: {
            type: Boolean,
            value: false
          },


          //
          // State management
          //

          initialized: {
            type: Boolean,
            value: false
          },

          paused: {
            type: Boolean,
            value: true
          },
          
          started: {
            type: Boolean,
            value: false
          },

          ended: {
            type: Boolean,
            value: false
          },

      	  /**
      	   * True only when the user has mistyped.
      	   * False when the typo is fixed.
      	   */
          _error: {
      	    type: Boolean,
      	    value: false
      	  },


          //
          // Editor inner working properties
          //
          
          /**
           * The preprocessed content to touch type. Could be different from `content` if long lines are detected for example.
           */
          _content: {
            type: String,
            value: ""
          },

          // The list of <span class="character"> elements representing the characters to enter
          _characters: {
            type: Array,
            value: []
          },

          // Line number containing the `_i` character.
          _currentLine: {
              type: Number,
              value: 0
          },

          // The index of the latest valid entered character
          _countValid: {
            type: Number,
            value: 0
          },          
          
          
          //
          // Styling
          //
          
          /**
           * If false, 	Sequences of whitespace will collapse into a single whitespace. 
           */
          preserveSpacing: {
            type: Boolean,
            value: true
          },
          
          /**
           * Size of text. Allowed values: 'normal', 'large'.
           */
          fontSize: {
            type: String,
            value: 'normal'
          },
          
          
          
        };
      }
      
      ready() {
        super.ready();
        this._addKeysListeners(); 
      }

      _contentChanged() {
        console.log('[typio-core-editor] content changed to', this._content);
        this._content = this.content;
      }
      
      /**
       * Called this method to reset the editor (ex: retry).
       */
      reset() {
        // Reset variables
        this._characters = [];
        this._i = -1;
        this._currentLine = 0;
        this._countValid = 0;

        // reset ready-screen
        this.initialized = false;
        this.started = false;
        this.paused = true;
        this.ended = false;
        
        this.refresh();
        this._removeKeysListeners();
        this._addKeysListeners();
      }

      refresh() {
        // Refresh editor
        this._parse();
      }
      
      _removeKeysListeners() {
        if (this._keydownListener) {
          document.removeEventListener('keydown', this._keydownListener);
        }
        if (this._keyupListener) {
          document.removeEventListener('keyup', this._keyupListener, false);
        }
        if (this._keypressListener) {
          document.removeEventListener('keypress', this._keypressListener, false);
        }
      }
      
      _addKeysListeners() {
        // We listen for tab character (match any number of consecutive characters)
        this._keydownListener = event => {
          //console.log('keydown', event);
          if (!this.started || event.ctrlKey) return;
          if (event.key !== 'Tab') return; // we are only interested by tabular character
          event.preventDefault();
          event.stopPropagation();
          this._checkInput(event, event.key);
          return false;
        };
        document.addEventListener('keydown', this._keydownListener);
                
        // We listen keyup for nonprintable characters
        this._keyupListener = event => {
          //console.log('keyup', event);
          if (!this.started) return;
          if (event.key === 'Backspace') {
            this.backward();
          }
        };
        document.addEventListener('keyup', this._keyupListener, false);

        // ... and keypress for printable ones (keypress support dead keys)
        this._keypressListener = event => {
          //console.log('keypress', event);
          if (!this.started) return;
          const keyName = event.key;

          if (keyName === 'Control') {
            // not alert when only Control key is pressed.
            return;
          }

          if (event.ctrlKey) {
            // Even though event.key is not 'Control' (i.e. 'a' is pressed),
            // event.ctrlKey may be true if Ctrl key is pressed at the time.
            ;
          } else {
            this._checkInput(event, keyName);
            event.preventDefault();
            return false;
          }
        };
        document.addEventListener('keypress', this._keypressListener, false);
      }
      
      /**
       * Called when the user has validated the ready screen.
       */
      start() {
        console.debug('[typio-core-editor] start with', this._content);
        this.initialized = true;
        this.started = true;
        this.numberLines = this._content.split('\n').length;

        // refresh the editor
        this.refresh();
      }

      /**
       * Parse the selected content to determine tokens.
       */
      _parse() {
        console.log('[typio-core-editor] Number of displayable lines: ' + countLines(this.$.editor));

        const startTime = performance.now();
        console.log('[typio-core-editor] _parse');

        this._i = -1;
        this._currentLine = 0;
        this._length = this._content.length;

        console.log('[typio-core-editor] lexical parser ... done in ' + (performance.now() - startTime) + 'ms');

        // TODO Add properties
        const classes = this.classes;
        const intervals = this.intervals;
        const logicalLines = this.logicalLines;
        // + continueOnErrors

        let fragment = document.createDocumentFragment();

        console.log('[typio-core-editor] Number of characters: ' + this._length);

        let lineNumber = 0;
        let newLine = true;

        for (let i = 0; i < this._length; i++) {
          let charTxt = this._content[i]; // The original character
          let charName = charTxt;        // The name as returned by the keypress/keyup event (see key property)
          let charPrint = charTxt;       // The character print on screen

          let charCode = this._content.charCodeAt(i);

          let span = document.createElement('span');
          span.classList.add('character', 'disabled'); // General classes
          if (classes) {
            span.classList.add(...classes[i]);
          } 
          if (intervals) {
            span.classList.add('interval-' + intervals[i]);
          }

          // HACK: http://www.adamkoch.com/2009/07/25/white-space-and-character-160/
          if (charCode === 160) {
            charName = ' ';
            charCode = 32;
          }

          if (newLine && logicalLines && !logicalLines[lineNumber]) { // continuation line
            charName = 'Continuation Line';
            charPrint = ' <strong>&#11153;</strong> \n';
            span.classList.add('continuation', 'ignorable');
          }

          if (charTxt == '\n') {
            // Put Unicode return symbol as content &#9166; (should be displayed only when actived)
            charName = 'Enter';
            charPrint = ' <strong>&#9166;</strong> \n';
            span.classList.add('print-on-focus');
            
            // Allow user to press space or nothing for continuation return line
            if (logicalLines && lineNumber + 1 < logicalLines.length && !logicalLines[lineNumber + 1]) {
              span.classList.add('allowSpace', 'optional');
            }

            newLine = true;
            lineNumber++;
          } else {
            newLine = false;
          }

          span.dataset.text = charName;
          span.innerHTML = charPrint;
          fragment.appendChild(span);
        }

        console.log('[typio-core-editor] other parser ... done in ' + (performance.now() - startTime) + 'ms');
        this.$.editor.innerHTML = '';
        this.$.editor.appendChild(fragment);

        this._characters = this.$.editor.querySelectorAll('.character');

        const endTime = performance.now();
        console.log('[typio-core-editor] _parse ... done in ' + (endTime - startTime) + 'ms');
        this.advance();
        this.initialized = true;
      }

      resume() {
        this.paused = false;
      }

      /**
       * Called after each key press.
       */
      _checkInput(event, keyName) {
        if (this.paused) {
          this.resume();
        }

        let character = this._cursor();
        let iCharacter = this._i;
        let valid = undefined;

        if (this.debug) {
          console.log('Expected: [' + character.dataset.text + '] (' + character.dataset.text.charCodeAt(0) + '), Got: [' + keyName + '] (' + keyName.charCodeAt(0) + '), valid=' + this._isValid(character, keyName) + ', position=' + this._i + ', error=' + this._error + ', positionError=' + this._iError);
        }
        
        // Allow optional character to be passed
        if (character.classList.contains('optional') && 
              !this._isValid(this._cursor(), keyName) &&
               this._isValid(this._nextNonIgnorableCharacter(), keyName)) {
          this.advance();
          character = this._cursor();
          iCharacter = this._i;
        }
        
        if (keyName === 'Tab' && this._canAdvance()) {
          // advance to the next nonspace character
          while (this._cursor().classList.contains('space')) {
            this.advance(); 
          }
          
        } else if (this._isValid(character, keyName)) {
          valid = true;
          character.classList.remove('disabled');
          
          if (this._error && this._iError == this._i) {
            console.log('[bug] remove error');
            character.classList.remove('char-invalid');
            this._error = false;
          }
          
          if (this.continueOnErrors) {
            character.classList.remove('char-invalid');
          } else if (this._error && !this.continueOnErrors) {
            character.classList.add('char-invalid');
          } else {
	          character.classList.remove('char-invalid');
	        }

          // Add marker to highlight mistyping at the end
          if (!character.classList.contains('wrong') && !character.classList.contains('useless')) {
            character.classList.add(this._error ? 'useless' : 'right');
          }

          if (!this._error) {
            this._countValid++;
          }
          this.advance();
          
        } else {
          valid = false;
          character.classList.add('char-invalid');
          character.classList.add('wrong');
          this._error = true;
          this._iError = this._i;
          this.$.editor.classList.add('error');
          this.advance();
        }

        // Update chart
        let accepted = valid || this.continueOnErrors;
        let detail = {
          "index": this._i,
          "indexValid": this._countValid,
          "line": this._currentLine,
          "character": iCharacter, 
          "keyName": keyName, 
          "valid": valid, 
          "accepted": accepted,         
        }
        this.dispatchEvent(new CustomEvent('character-entered', {detail: detail, bubbles: true, composed: true}));
      }

      _isValid(character, keyName) {
        if (character == undefined) return false;
        
        const expectedCharacter = character.dataset.text;
        
        // nominal case
        if (keyName === expectedCharacter) {
          return true;
        }
        
        // Manage exceptions:
        
        // Curved quotes are not typeable => allow simple quote
        if (keyName === "'" && (expectedCharacter === '‘' || expectedCharacter === '’')) {
          return true;
        }
        if (keyName === '"' && (expectedCharacter === '“' || expectedCharacter === '”')) {
          return true;
        }
        
        // Allow space for some indentation characters
        if (keyName === ' ' && character.classList.contains("allowSpace")) {
          return true;
        }
        
        // Nothing matches
        return false;
      }
      
      /**
       * Move backward to the previous editable character.
       */
      backward() {
        if (this._i == 0) return; // Do nothing if at start

        do {
          this._unhighlight();
          this._backwardOneCharacter();

          if (this._error && this._i === this._iError) {
            this._error = false;
            this.$.editor.classList.remove('error');
          }
        } while (this._isIgnorable());

        if (this._i >= 0) {
          this._highlight();
        }
      }

      /**
       * Move forward to the next editable character.
       */
      advance() {
        if (this._i >= 0) {
          this._cursor().classList.remove('char-active');
        }

        if (this._isEndOfFile()) {
          // Do not trigger end if there is error, except if allowed
          if (this._allowToEnd()) {
            this.end();
          }
          return;
        }

        this._advanceOneCharacter();
        while (!this._isEndOfFile() && this._isIgnorable()) { this._advanceOneCharacter(); }

        this._highlight();
      }
      
      _canAdvance() {
        return !this.error || this.continueOnErrors;
      }

      /**
       * Move backward to the previous character (editable or not editable.)
       */
      _advanceOneCharacter() {
        this._i++;

        // Check if a new line have been triggered
        if (this._triggerNewLine) {
          this._currentLine++;
          console.log("Triggering new line...", this.mode)
          if (this.mode === 'scroll') this._scrollEditor();
          if (this.mode === 'page') this._updatePage();
          this._triggerNewLine = false;
        }

        if (this._cursor().classList.contains('backslash')) {
          // We need to wait the user press 'Enter' before advance the line number.
          // Because if is press the wrong key, we will stay on the same line...
          this._triggerNewLine = true;
        } else {
          this._triggerNewLine = false;
        }
      }

      /**
       * Move forward to the next character (editable or not editable.)
       */
      _backwardOneCharacter() {
        this._i--;
        this._triggerNewLine = false;
        if (this._cursor().classList.contains('backslash')) {
          this._currentLine--;
          if (this.mode === 'scroll') this._scrollEditor();
        }
      }

      /**
       * Scroll to position the current line on screen
       * For performance reason, this method only need to call after each newline character.
       */
      _scrollEditor() {
        if (this._currentLine > 5 && this._currentLine < this.numberLines - 5) { // do not scroll too soon. Wait for some lines.
          this._scrollToLine(this._currentLine - 5);
        }
      }

      /**
       * Update the editor to display the current page.
       */
      _updatePage() {
        const numberLinesPrintable = countLines(this.$.editor);
        const numberLinesTotal = this.numberLines;
        const pageNumber = parseInt(this._currentLine / numberLinesPrintable) +
          ((this._currentLine % numberLinesPrintable == 0) ? 0 : 1); // + 1 if remainder
        const numberLinesToScroll = (pageNumber > 1) ? (pageNumber - 1) * numberLinesPrintable : 0;

        console.log('[typio-core-editor] Scroll to page ' + pageNumber + ' by shifting ' + numberLinesToScroll + ' lines');
        this._scrollToLine(numberLinesToScroll);
      }

      /**
       * Scroll to position the given line at the top of the editor.
       * For performance reason, this method only need to call after each newline character.
       */
      _scrollToLine(lineNumber) {
        console.log('[typio-core-editor] Scroll to line ' + lineNumber);
        this.$.editor.style.marginTop = lineNumber * -1.5 + 'em'; // see #editor line-height property
      }

      /**
       * Have we reached the end of text?
       */
      _allowToEnd() {
        return this._error == false || this.continueOnErrors;
      }

      /**
       * Marks the end of the typing session.
       */
      end() {
        this.ended = true;
        this.dispatchEvent(new CustomEvent('typing-ended', {detail: {length: this._length}}));
        this._removeKeysListeners();
      }
      
      showMispellings() {
        this.$.editor.classList.add('highlight-mistyping');
      }
      
      hideMispellings() {
        this.$.editor.classList.remove('highlight-mistyping');
      }

      // Utility methods to manipulate current character

      _cursor() {
        return this._characters[this._i];
      }
      
      _nextNonIgnorableCharacter() {
        let i = this._i + 1;
        while (true) {
          if (this._isEndOfFile()) return undefined;
          let character = this._characters[i++];
          if (!character.classList.contains('ignorable')) {
            return character;
          }
        }
      }

      _isIgnorable() {
        let character = this._cursor();
        return character.classList.contains('ignorable');
      }

      _isEndOfFile() {
        return this._i + 1 >= this._length;
      }

      _highlight() {
        let character = this._cursor();
        character.classList.remove('char-invalid');
        character.classList.add('char-active');
        character.classList.add('disabled');
      }

      _unhighlight() {
        let character = this._cursor();
        character.classList.remove('char-active');
        character.classList.remove('char-invalid');
        character.classList.add('disabled');
      }
      
      // Intervals management
      
      selectInterval(column) {
        if (this.$.editor.classList.contains('highlight-interval-' + column)) {
          // unselect
          this.$.editor.classList.remove('highlight-interval-' + column);
        } else {
          // unselect all
          for (let i = 0; i < this.intervals.length; i++) {
            this.$.editor.classList.remove('highlight-interval-' + i);
          }
          // and select the selected one
          this.$.editor.classList.add('highlight-interval-' + column);
        }

        // Scroll to the interval in the editor
        this.moveToPage(this._getIntervalPage(column));
      }

      // Return the page number (0-based) containing the ith interval.
      _getIntervalPage(i) {
        if (this.intervals.length < i) { // Intervals was not defined
          return;
        }
        const indexFirstCharacter = this.intervals.indexOf(i);
        const lineFirstCharacter = this._content.substring(0, indexFirstCharacter).split('\n').length + 1;
        this._currentLine = Math.max(lineFirstCharacter - 5, 0); // Add some lines before to add context
        this._scrollToLine(this._currentLine);
      }
      

      //
      // Page controls
      //

      moveToFirstPage() {
        this._currentLine = 0;
        this._scrollToLine(0);
      }

      moveToPreviousPage() {
        const numberLinesPrintable = countLines(this.$.editor);
        const numberLinesTotal = this.numberLines;
        this._currentLine -= numberLinesPrintable;
        if (this._currentLine < 0) {
          this.moveToFirstPage();
        } else {
          this._scrollToLine(this._currentLine);
        }
      }

      moveToNextPage() {
        const numberLinesPrintable = countLines(this.$.editor);
        const numberLinesTotal = this.numberLines;
        this._currentLine += numberLinesPrintable;
        if (this._currentLine > numberLinesTotal) {
          this.moveToLastPage();
        } else {
          this._scrollToLine(this._currentLine);
        }
      }

      moveToLastPage() {
        const numberLinesPrintable = countLines(this.$.editor);
        const numberLinesTotal = this.numberLines;
        this._currentLine = Math.floor(numberLinesTotal / numberLinesPrintable) * numberLinesPrintable;
        this._scrollToLine(this._currentLine);
      }

      moveToPage(n) {
        const numberLinesPrintable = countLines(this.$.editor);
        const numberLinesTotal = this.numberLines;
        if (n * numberLinesPrintable > numberLinesTotal) {
          this.moveToLastPage();
        } else if (n <= 0) {
          this.moveToFistPage();
        } else {
          this._currentLine = n * numberLinesPrintable;
          this._scrollToLine(this._currentLine);
        }
      }

      _updatePage() {
        const numberLinesPrintable = countLines(this.$.editor);
        const numberLinesTotal = this.numberLines;

        const pageNumber = parseInt(this._currentLine / numberLinesPrintable) +
          ((this._currentLine % numberLinesPrintable == 0) ? 0 : 1); // + 1 if remainder
        const numberLinesToScroll = (pageNumber > 1) ? (pageNumber - 1) * numberLinesPrintable : 0;

        console.log('[typio-core-editor] Scroll to page ' + pageNumber + ' by shifting ' + numberLinesToScroll + ' lines');
        this._scrollToLine(numberLinesToScroll);
      }


    }
    window.customElements.define(TypioCoreEditor.is, TypioCoreEditor);

    /**
     * Determine the number of text lines inside an HTML element.
     *
     * @param {HTMLElement} element the element to evaluate.
     */
    function countLines(element) {
      // see https://stackoverflow.com/questions/8606588/how-to-get-the-line-height-of-a-span?rq=1
      let style = window.getComputedStyle(element);
      let divHeight = element.offsetHeight;
      let lineHeight = parseInt(style.lineHeight);
      return parseInt(divHeight / lineHeight);
    }

  </script>
</dom-module>
