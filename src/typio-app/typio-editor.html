<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/polymer/lib/utils/flattened-nodes-observer.html">

<link rel="import" href="/src/typio-app/shared-styles.html">
<link rel="import" href="/src/typio-app/typio-viewer.html">

<dom-module id="typio-editor">

  <script>

    /**
     * Editor screen (where text to type is displayed).
     *
     * @customElement
     * @polymer
     */
    class TypioEditor extends TypioViewer {

      static get is() { return 'typio-editor'; }
      static get properties() {
        return {

          // 
          // + typio-viewer properties
          //
          
          // Override
          controls: {
            type: Boolean,
            value: false
          },

          /**
           * Let the user continues typing when an error occurs.
           * If false, the session will not end until all characters are valid.
           */
          continueOnErrors: {
            type: Boolean,
            value: false
          },
          

          //
          // State management
          //

          initialized: {
            type: Boolean,
            value: false
          },

          paused: {
            type: Boolean,
            value: true
          },
          
          started: {
            type: Boolean,
            value: false
          },

          ended: {
            type: Boolean,
            value: false
          },
          
          
          //
          // Error management
          //

      	  /**
      	   * True only when the user has mistyped.
      	   * False when the typo is fixed.
      	   */
          error: {
      	    type: Boolean,
      	    value: false
      	  },
          
          /** 
           * The position where the error is located. (0-based index)
           * Returns `undefined` if `error` is false.
           */
          positionError: {
            type: Number,
            value: undefined
          },


          //
          // Editor inner working properties
          //
          
          // The index of the latest valid entered character
          _countValid: {
            type: Number,
            value: 0
          },          
          
        };
      }
      
      ready() {
        super.ready();
        this.reset();
        this._addKeysListeners(); 
      }

      /**
       * Called this method to reset the editor (ex: retry).
       */
      reset() {
        super.reset();
        
        // reset editor styles
        this.unhighlightAll();
        this.unannotateAll('disabled');
        this.unannotateGlobal('error');
        this.hideMispellings();
        
        // reset variables
        this.error = false;
        this.positionError = undefined;
        this._countValid = 0;        

        // reset ready-screen
        this.initialized = false;
        this.started = false;
        this.paused = true;
        this.ended = false;
      }

      _removeKeysListeners() {
        if (this._keydownListener) {
          console.log("remove 'keydown' listener");
          document.removeEventListener('keydown', this._keydownListener);
        }
        if (this._keyupListener) {
          console.log("remove 'keyup' listener");
          document.removeEventListener('keyup', this._keyupListener, false);
        }
        if (this._keypressListener) {
          console.log("remove 'keypress' listener");
          document.removeEventListener('keypress', this._keypressListener, false);
        }
      }
      
      _addKeysListeners() {
        // We listen for tab character (match any number of consecutive characters)
        this._keydownListener = event => {
          //console.log('keydown', event);
          if (!this.started || event.ctrlKey) return;
          if (event.key !== 'Tab') return; // we are only interested by tabular character
          event.preventDefault();
          event.stopPropagation();
          this._checkInput(event, event.key);
          return false;
        };
        document.addEventListener('keydown', this._keydownListener);
                
        // We listen keyup for nonprintable characters
        this._keyupListener = event => {
          //console.log('keyup', event);
          if (!this.started || event.ctrlKey) return;
          if (event.key === 'Backspace') {
            this.backward();
          }
        };
        document.addEventListener('keyup', this._keyupListener, false);

        // ... and keypress for printable ones (keypress support dead keys)
        this._keypressListener = event => {
          //console.log('keypress', event);
          if (!this.started) return;
          const keyName = event.key;

          if (keyName === 'Control') {
            // not alert when only Control key is pressed.
            return;
          }

          if (event.ctrlKey) {
            // Even though event.key is not 'Control' (i.e. 'a' is pressed),
            // event.ctrlKey may be true if Ctrl key is pressed at the time.
            ;
          } else {
            this._checkInput(event, keyName);
            event.preventDefault();
            return false;
          }
        };
        document.addEventListener('keypress', this._keypressListener, false);
      }
      
      /**
       * Called when the user has validated the ready screen.
       */
      start() {
        console.debug('[typio-core-editor] start with', this._content);
        this.initialized = true;
        this.started = true;
        this.numberLines = this._content.split('\n').length;

        // refresh the viewer
        super.refresh();
        
        this.initialized = true;
        this.annotateAll('disabled');
        this.advance();
      }

      /**
       * Pause the practice session.
       */
      resume() {
        this.paused = false;
      }
      
      /**
       * Marks the end of the typing session.
       */
      end() {
        this.ended = true;
        this.dispatchEvent(new CustomEvent('typing-ended', {detail: {length: this._length}}));
      }

      /**
       * Called after each key press.
       */
      _checkInput(event, keyName) {
        if (!this.started || this.ended) {
          // ignore input outside practice sessions
          return;
        }
        
        if (this.paused) {
          this.resume();
        }
        
        const startTime = performance.now();
        let valid = undefined;

        if (this.debug) {
          console.log('Expected: [' + this.character() + '] (' + this.character().charCodeAt(0) + '), Got: [' + keyName + '] (' + keyName.charCodeAt(0) + '), valid=' + this._isValid(this.element(), keyName) + ', position=' + this.position + ', error=' + this.error + ', positionError=' + this.positionError);
        }
        
        // Allow optional character to be passed
        if (this.hasAnnotation('optional') && 
              !this._isValid(this.element(), keyName) &&
               this._isValid(this._nextNonIgnorableElement(), keyName)) {
          this.advance();
        }
        
        if (keyName === 'Tab' && this._canAdvance()) {
          // advance to the next nonspace character
          while (this.hasAnnotation('space')) {
            this.advance(); 
          }
          
        } else if (this._isValid(this.element(), keyName)) {
          valid = true;
          this.unannotate('disabled');
          
          if (this.error && this.positionError == this.position) {
            console.log('[bug] remove error');
            this.unannotate('char-invalid', 'wrong');
            this.error = false;
            this.positionError = undefined;
          }
          
          if (this.continueOnErrors) {
            this.unannotate('char-invalid');
          } else if (this.error && !this.continueOnErrors) {
            this.annotate('char-invalid');
          } else {
	          this.unannotate('char-invalid');
	        }

          // Add marker to highlight mistyping at the end
          if (!this.hasAnnotation('wrong') && !this.hasAnnotation('useless')) {
            this.annotate(this.error ? 'useless' : 'right');
          }

          if (!this.error) {
            this._countValid++;
          }
          this.advance();
          
        } else {
          valid = false;
          this.error = true;
          this.positionError = this.position;
          this.annotate('char-invalid', 'wrong');
          this.annotateGlobal('error');
          this.advance();
        }

        // Notify about entered input
        let accepted = valid || this.continueOnErrors;
        let detail = {
          "index": this.position,
          "indexValid": this._countValid,
          "line": this._currentLine,
          "character": this.position, 
          "keyName": keyName, 
          "valid": valid, 
          "accepted": accepted,         
        }
        this.dispatchEvent(new CustomEvent('character-entered', {detail: detail, bubbles: true, composed: true}));
        
        if (this.profile) {
          console.log('[typio-editor] checking input done in ' + (performance.now() - startTime) + 'ms');
        }
      }

      _isValid(character, keyName) {
        if (character == undefined) return false;
        
        const expectedCharacter = character.dataset.text;
        
        // nominal case
        if (keyName === expectedCharacter) {
          return true;
        }
        
        // Manage exceptions:
        
        // Curved quotes are not typeable => allow simple quote
        if (keyName === "'" && (expectedCharacter === '‘' || expectedCharacter === '’')) {
          return true;
        }
        if (keyName === '"' && (expectedCharacter === '“' || expectedCharacter === '”')) {
          return true;
        }
        
        // Allow space for some indentation characters
        if (keyName === ' ' && this.hasAnnotationElement(character, "allowSpace")) {
          return true;
        }
        
        // Nothing matches
        return false;
      }
      
      /**
       * Move backward to the previous editable character.
       */
      backward() {
        if (this.position == 0) return; // Do nothing if at start

        do {
          this._unselect();
          this._backwardOneCharacter();

          if (this.error && this.position === this.positionError) {
            this.error = false;
            this.positionError = undefined;
            this.unannotateGlobal('error');
            this.unannotate('char-invalid', 'wrong');
          }
        } while (this.hasAnnotation('ignorable'));

        if (this.position >= 0) {
          this._select();
        }
      }

      /**
       * Move forward to the next editable character.
       */
      advance() {
        if (this.position >= 0) {
          this.unannotate('char-active');
        }

        if (this.endOfFile()) {
          // Do not trigger end if there is error, except if allowed
          if (this._allowToEnd()) {
            this.end();
          }
          return;
        }

        this._advanceOneCharacter();
        while (!this.endOfFile() && this.hasAnnotation('ignorable')) { console.log('advance'); this._advanceOneCharacter(); }
        this._select();
      }
      
      _canAdvance() {
        return !this.error || this.continueOnErrors;
      }

      /**
       * Move backward to the previous character (editable or not editable.)
       */
      _advanceOneCharacter() {
        this.position++;

        // Check if a new line have been triggered
        if (this._triggerNewLine) {
          this._currentLine++;
          console.log("Triggering new line...", this.mode);
          // FIXME what to do instead?
          //if (this.mode === 'scroll') this._scrollEditor();
          //if (this.mode === 'page') this._updatePage();
          this._triggerNewLine = false;
        }

        if (this.hasAnnotation('backslash')) {
          // We need to wait the user press 'Enter' before advance the line number.
          // Because if is press the wrong key, we will stay on the same line...
          this._triggerNewLine = true;
        } else {
          this._triggerNewLine = false;
        }
      }

      /**
       * Move forward to the next character (editable or not editable.)
       */
      _backwardOneCharacter() {
        this.position--;
        this._triggerNewLine = false;
        if (this.hasAnnotation('backslash')) {
          this._currentLine--;
          // FIXME what to do instead?
        }
      }

      /**
       * Have we reached the end of text?
       */
      _allowToEnd() {
        return this.error == false || this.continueOnErrors;
      }

      _select() {
        this.unannotate('char-invalid');
        this.annotate('char-active', 'disabled');
      }

      _unselect() {
        this.unannotate('char-active', 'char-invalid');
        this.annotate('disabled');
      }
      
      showMispellings() {
        this.annotateGlobal('highlight-mistyping');
        this.controls = true;
      }
      
      hideMispellings() {
        this.unannotateGlobal('highlight-mistyping');
        this.controls = false;
      }
      
      /**
       * Return the next character which doesn't have the `ignorable` annotation.
       */
      _nextNonIgnorableElement() {
        let i = this.position + 1;
        while (true) {
          if (this.endOfFile()) return undefined;
          let element = this.elementAt(i++);
          if (!this.hasAnnotationElement(element, 'ignorable')) {
            return element;
          }
        }
      }
      
    }
    window.customElements.define(TypioEditor.is, TypioEditor);

  </script>
</dom-module>
