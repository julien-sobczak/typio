<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/polymer/lib/utils/flattened-nodes-observer.html">
<link rel="import" href="../../bower_components/paper-toggle-button/paper-toggle-button.html">
<link rel="import" href="../../bower_components/google-chart/google-chart.html">

<link rel="import" href="../../bower_components/app-layout/app-layout.html">
<link rel="import" href="../../bower_components/app-layout/app-scroll-effects/effects/waterfall.html">

<link rel="import" href="/src/typio-app/typio-ready-screen.html">
<link rel="import" href="/src/typio-app/typio-stats.html">
<link rel="import" href="/src/typio-app/typio-parser.html">
<link rel="import" href="/src/typio-app/shared-styles.html">

<dom-module id="typio-editor">
  <template>
    <style include="shared-styles">

      :host {
        display: block;
      }

      /* Following style was inspired by https://typing.io/ */

      span {
        padding: .1em 0;
      }
      span.disabled {
        color: #737373 !important;
      }
      span.print-on-focus {
        visibility: hidden;
      }
      span.char-invalid.print-on-focus {
        visibility: visible !important;
      }
      span.char-active.print-on-focus {
        visibility: visible;
      }

      /* We need !important to override special code
      such as operator, comment that also define a background. */
      span.char-active {
        background-color: #47d42b !important;
        outline: 1px solid #40be27 !important;
        color: #fff !important;
      }
      span.char-invalid {
        background-color: #e63d3d !important;
        outline: none !important;
        color: #fff !important;
      }
      span.char-active.paused {
        background-color: #ffc40d !important;
        outline: 1px solid #f3b700 !important;
        color: #fff !important;
      }

      #editor.highlight-mistyping span.useless {
        background-color: #faa937;
        outline: 1px solid #faa937;
        color: #fff !important;
      }
      #editor.highlight-mistyping span.wrong {
        background-color: #d51b1b;
        outline: 1px solid #d51b1b;
        color: #fff !important;
      }

      #content {
        width: 1000px;
        margin: 0 auto;
        padding: 1cm;
        position: fixed;
        top: 64px;
        bottom: 50px;
        z-index: 40;
        left: 50%;
        margin-left: -400px; /* Half of the width */
        
        overflow-y: hidden;
        overflow-x: visible;
      }
      #content pre[data-type="text"]  {
        font-family: 'Droid Sans Mono', monospace;
      }
      #content pre[data-type="code"] {
        font-family: monospace;
      }
      
      /* Show a gradient at the bottom to show there is text that follows. */      
      #screen.mode-scroll #content:after {
        content: '';
        width: 100%;
        height: 100%;    
        position: absolute;
        z-index: 500;
        left: 0;
        bottom: 0;
        background: linear-gradient(transparent 90%, white);
      }   
      
      #screen.showChart-true #content {
        bottom: 150px; /* Reserve space to show chart. */
      }
  

      #editor {
        line-height: 1.5em;
        height: 100%;

        transition: margin 300ms; /* Used in Scroll Mode */
      }
      
      #editor.highlight-interval-0 span.interval-0,
      #editor.highlight-interval-1 span.interval-1,
      #editor.highlight-interval-2 span.interval-2,
      #editor.highlight-interval-3 span.interval-3,
      #editor.highlight-interval-4 span.interval-4,
      #editor.highlight-interval-5 span.interval-5,
      #editor.highlight-interval-6 span.interval-6,
      #editor.highlight-interval-7 span.interval-7,
      #editor.highlight-interval-8 span.interval-8,
      #editor.highlight-interval-9 span.interval-9,
      #editor.highlight-interval-10 span.interval-10 {
        background-color: Gold !important;
        outline: none !important;
        color: black !important;
      }

      #resourceName {
        position: fixed;
        top: 17px;
        height: 30px;
        left: 50%;
        width: 650px;
        margin-left: -250px;
        padding: 5px 25px;
        color: white;
        background: rgba(0, 0, 0, 0.5);
        z-index: 150;
        text-align: center;
        border-radius: 15px;
        overflow: hidden;
      }
      
      
      #stats {
        position: fixed;
        top: 0;
        right: 0;
        padding: 1in;
        transition: width 0.5s, height 0.5s;
      }

      #chart {
        display: none;
        /*
          There is a bug that displays:
            'TypeError: cannot read property 'draw' of null'
          on load time during a short time before showing the chart correctly.

          As a hack, we hide the chart until the last moment.
          At this time, the error message was already printed
          and we can reveal the chart.
         */
        height: 100px;
        width: 100%;
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
      }
      
      /* Support option "Show Chart" */
      #chart.showChart-false {
        display: none !important;
      }


      /*
       * Menu
       */

      app-toolbar {
        background-color: var(--typio-bg-color);
        color: white;
        font-family: 'Cutive', serif;
      }

      paper-icon-button {
        --paper-icon-button-ink-color: white;
      }

      paper-icon-button + [main-title] {
        margin-left: 24px;
      }
      app-header {
        @apply --layout-fixed-top;
        color: #fff;
        box-shadow: 0 5px 5px rgba(0, 0, 0, 0.3);
        z-index: 100;
        --app-header-background-rear-layer: {
          background-color: #ef6c00;
        };
      }
      app-drawer {
        z-index: 50;
        --app-drawer-scrim-background: rgba(255, 255, 255, 0.6);
        --app-drawer-content-container: {
          background-color: white;
        }
      }
      app-drawer nav {
        margin-top: 100px;
      }
      app-drawer nav ul {
        list-style-type: none;
      }
      app-drawer nav li {
        border: none;
      }
      app-toolbar a {
        text-decoration: none;
        color: inherit;
        margin-left: 25px;
      }
      app-drawer a {
        text-decoration: none;
        color: inherit;
      }

      #screen.initialized-false {
        display: none;
      }
      #screen.initialized-true {
        display: block;
      }

    </style>

    <app-header effects="waterfall">
      <app-toolbar>
        <paper-icon-button icon="menu" on-click="_toggleDrawer"></paper-icon-button>
        <a href="/intro">TYPIO</a>
        <div main-title></div>
        <a href="/catalog"><paper-icon-button icon="close"></paper-icon-button></a>
      </app-toolbar>
    </app-header>
    <app-drawer id="drawer" swipe-open>
      <nav>
        <ul>
          <li><paper-icon-button icon="close"></paper-icon-button> <a href="/catalog">Catalog</a></li>
        </ul>
      </nav>
    </app-drawer>

    <typio-ready-screen id="readyScreen"
        type="[[type]]"
        language="[[language]]"
        content="{{content}}"
        ignore-comments="{{settings.ignoreComments}}"
        ignore-indents="{{settings.ignoreIndents}}"
        continue-on-errors="{{settings.continueOnErrors}}"
        show-chart="{{settings.showChart}}"
        mode="{{settings.mode}}"
        on-ready="start">
    </typio-ready-screen>

    <typio-parser id="parser"
        type="[[type]]"
        language="[[language]]"
        content="[[content]]"
        ignore-comments="[[settings.ignoreComments]]"
        ignore-indents="[[settings.ignoreIndents]]">
    </typio-parser>

    <div id="screen" class$="initialized-[[initialized]] showChart-{{showChart}} mode-{{mode}}">

      <template is="dom-if" if="{{resource}}">
        <div id="resourceName">
          <strong>[[resource]]</strong> | [[resourceItem]]
        </div>
      </template>

      <typio-stats id="stats"></typio-stats>

      <div id="content">
        <pre id="editor" data-type$="[[type]]">[[content]]</pre>
      </div>

      <google-chart id="chart" class$="showChart-{{showChart}}"
        type="stepped-area"
        options="[[chartOptions]]"
        cols="[[chartCols]]"
        rows='[]'>
      </google-chart>

    </div>

  </template>

  <script>

    /**
     * @customElement
     * @polymer
     */
    class TypioEditor extends Polymer.Element {

      static get is() { return 'typio-editor'; }
      static get properties() {
        return {

          route: {
            type: Object
          },

          /**
           * The type of content (code, literature).
           */
          type: {
            type: String,
            value: "code"
          },

          /**
           * Language of the content.
           *
           * Could be a programming language (Java, Python) or a
           * spoken language (French, English).
           *
           * Note: Case is not important.
           */
          language: {
            type: String,
            value: "Python"
          },

          /**
           * The name of the resource where the content is extracted.
           * Could be a book title or a Github project name.
           */
          resource: {
            type: String,
            value: null
          },

          /**
           * A reference to idemtity the content inside the resource.
           * Could be a chapter title, or a file path.
           */
          resourceItem: {
            type: String,
            value: null
          },

          /**
           * The content to touch type.
           *
           * This property should be set in JavaScript and
           * not through an HTML attribute to avoid HTML escaping (&lt; for <).
           */
          content: {
            type: String,
            value: 'import sys\n\ndef main():\n  print("Hello World")\n  sys.exit(0)\n'
          },
          
          /**
           * The number of lines in `content`.
           */          
          numberLines: {
            type: Number,
            value: 0
          },
          
          /**
           * Log debug information to the console.
           */
          debug: {
            type: Boolean,
            value: false
          },

          /**
           * Settings
           */
          settings: {
            type: Object,
            value: {
              ignoreComments: true,
              ignoreIndents: true,
              continueOnErrors: false,
              showChart: true,
              mode: 'scroll'
            }
          },


          /*
           * State management
           */

          initialized: {
            type: Boolean,
            value: false
          },

          paused: {
            type: Boolean,
            value: true
          },

          ended: {
            type: Boolean,
            value: false
          },


          //
          // Editor inner working properties
          //

          // The list of <span class="character"> elements representing the characters to enter
          _characters: {
            type: Array,
            value: []
          },

          // The index of the current editable element
          _i: {
              type: Number,
              value: -1
          },
          
          // Line number containing the `_i` character.
          _currentLine: {
              type: Number,
              value: 0
          },

          // The index of the latest valid entered character
          _countValid: {
            type: Number,
            value: 0
          },


          //
          // Google Chart Configuration
          // See https://developers.google.com/chart/interactive/docs/gallery/steppedareachart
          //

          chartOptions: {
            type: Object,
            readOnly: true,
            value: {
              "title": "WPM",
              "legend": "none",
              "fontName": "Cutive",
              "areaOpacity": 1,
              "tooltip": {"trigger": "none"},
              "chartArea": {
                "left": 0,
                "top": 0,
                "width": "100%",
                "height": "100%",
                "backgroundColor": {"strokeWidth": 0}
              },
              "hAxis": { "textPosition": "in", "textStyle": { "color": "black", "bold": true, "auraColor": "none" } },
              "vAxis": {
                "textPosition": "int",
                "minValue": 0,
                "maxValue": 200,
                "gridlines": { "count": 0 }
              },
              "colors": ["#009ee3"],
              "lineWidth": 2,
              "annotations": {"textStyle": { "color": "orange"} }
            }
          },

          chartCols: {
            type: Array,
            readOnly: true,
            value: [
              {"label": "Progress", "type": "string"},
              {"label": "WPM",      "type": "number"},
              {"type": "string",    "role": "annotation"},
              {"type": "string",    "role": "style"}
              // see https://developers.google.com/chart/interactive/docs/roles?hl=en for the role property of columns
            ]
          },


        };
      }

      ready() {
        super.ready();

        // We listen keyup for nonprintable characters
        document.addEventListener('keyup', (event) => {
          if (!this.initialized) return;
          if (event.key === 'Backspace') {
            this.backward();
          }
        });

        // ... and keypress for printable ones (keypress support dead keys)
        document.addEventListener('keypress', (event) => {
          if (!this.initialized) return;
          const keyName = event.key;
          const keyCode = event.code;

          if (keyName === 'Control') {
            // not alert when only Control key is pressed.
            return;
          }

          if (event.ctrlKey) {
            // Even though event.key is not 'Control' (i.e. 'a' is pressed),
            // event.ctrlKey may be true if Ctrl key is pressed at the time.
            ;
          } else {
            this.checkInput(event, keyName);
            event.preventDefault();
            return false;
          }

        }, false);
      }

      reset() {
        // Reset variables
        this.$.stats.reset();
        this._characters = [];
        this._i = -1;
        this._currentLine = 0;
        this._countValid = 0;

        // reset ready-screen
        this.initialized = false;
        this.$.readyScreen.hidden = false;

        this.refresh();
      }

      refresh() {
        // Refresh editor
        this._updateContent();
      }

      start(e, detail) {
        this.content = this._preprocess(detail.selection);
        this.numberLines = this.content.split('\n').length;
        this.ignoreComments = detail.ignoreComments;
        this.ignoreIndents = detail.ignoreIndents;
        this.continueOnErrors = detail.continueOnErrors;
        this.showChart = detail.showChart;
        this.mode = detail.mode;
        this.initialized = true;

        this._updateContent();
      }

      _updateContent() {
        this._parse();
      }
      
      _preprocess(txt) {
        return txt.replace(/\r\n/g, '\n');
      }

      _parse() {
        console.log('[typio-editor] Number of displayable lines: ' + countLines(this.$.editor));
        
        const startTime = performance.now();
        console.log('[typio-editor] _parse');
        
        this._i = -1;
        this._currentLine = 0;
        this._length = this.content.length;
        
        this.$.parser.parse();
        console.log('[typio-editor] lexical parser ... done in ' + (performance.now() - startTime) + 'ms');
        
        const classes = this.$.parser.classes;        
        const editableCharacters = this._calculateEditableCharacters(classes);
        const intervals = this.$.stats.intervals;

        let fragment = document.createDocumentFragment();

        console.log('[typio-editor] Number of characters: ' + this._length);
        for (let i = 0; i < this._length; i++) {
          let charTxt = this.content[i]; // The original character
          let charName = charTxt;        // The name as returned by the keypress/keyup event (see key property)
          let charPrint = charTxt;       // The character print on screen

          let charCode = this.content.charCodeAt(i);
          let charClasses = classes[i];
          
          // HACK: http://www.adamkoch.com/2009/07/25/white-space-and-character-160/
          if (charCode === 160) {
            charName = ' ';
            charCode = 32;
          }

          let span = document.createElement('span');
          span.classList.add(...charClasses);
          span.classList.add('interval-' + intervals[i]);

          if (charTxt == '\n') {
            // Put Unicode return symbol as content &#9166; (should be displayed only when actived)
            charName = 'Enter';
            charPrint = ' <strong>&#9166;</strong> \n';
            span.classList.add('print-on-focus');
          }

          span.dataset.text = charName;
          span.innerHTML = charPrint;
          fragment.appendChild(span);
        }

        console.log('[typio-editor] other parser ... done in ' + (performance.now() - startTime) + 'ms');
        this.$.editor.innerHTML = '';
        this.$.editor.appendChild(fragment);

        this._characters = this.$.editor.querySelectorAll('.character');
        this.$.stats.editableCharacters = editableCharacters;

        const endTime = performance.now();
        console.log('[typio-editor] _parse ... done in ' + (endTime - startTime) + 'ms');
        this.advance();
      }

      _calculateEditableCharacters(classes) {
        let editableCharacters = new Array(this._length);
        for (let i = 0; i < this._length; i++) {
          editableCharacters[i] = !classes.includes('ignorable');
        }
        return editableCharacters;
      }

      resume() {
        this.paused = false;
        this.$.stats.resumeTimer();
      }

      checkInput(event, keyName) {
        if (this.paused) {
          this.resume();
        }

        let character = this._cursor();
        let iCharacter = this._i;
        let valid = undefined;

        if (this.debug) {
          console.log('Expected: [' + character.dataset.text + '] (' + character.dataset.text.charCodeAt(0) + '), Got: [' + keyName + '] (' + keyName.charCodeAt(0) + ')');
        }
        if (this._isValid(character, keyName)) {
          valid = true;
          character.classList.remove('disabled');
          if (this.continueOnErrors) {
            character.classList.remove('char-invalid');
          } else if (this._error && !this.continueOnErrors) {
            character.classList.add('char-invalid');
          }

          // Add marker to highlight mistyping at the end
          if (!character.classList.contains('wrong') && !character.classList.contains('useless')) {
            character.classList.add(this._error ? 'useless' : 'right');
          }

          if (!this._error) {
            this._countValid++;
          }
          this.advance();
        } else {
          valid = false;
          character.classList.add('char-invalid');
          character.classList.add('wrong');
          this._error = true;
          this._iError = this._i;
          this.$.editor.classList.add('error');
          this.advance();
        }

        // Update chart
        let accepted = valid || this.continueOnErrors;
        this.$.stats.newCharacter(iCharacter, keyName, valid, accepted);

        this.$.chart.style.display = 'block';
        this.$.chart.rows = this.$.stats.wpmPerInterval();
        this.$.chart.redraw();
        this.listenChartEvents();
      }
      
      _isValid(character, keyName) {
        if (character.dataset.text === keyName) {
          return true;
        }        
        if (keyName === ' ' && character.classList.contains("allowSpace")) {
          return true;
        }
        return false;
      }

      backward() {
        if (this._i == 0) return; // Do nothing if at start

        do {
          this._unhighlight();
          this._backwardOneCharacter();

          if (this._error && this._i === this._iError) {
            this._error = false;
            this.$.editor.classList.remove('error');
          }
        } while (this._isIgnorable());

        if (this._i >=0) {
          this._highlight();
        }
      }

      advance() {
        if (this._i >= 0) {
          this._cursor().classList.remove('char-active');
        }
        
        if (this._isEndOfFile()) {
          // Do not trigger end if there is error, except if allowed
          if (this._allowToEnd()) {
            this.end();
          }
          return;
        }
        
        this._advanceOneCharacter();
        while (!this._isEndOfFile() && this._isIgnorable()) { this._advanceOneCharacter(); }
        
        this._highlight();
      }
      
      _advanceOneCharacter() {
        this._i++;
        
        // Check if a new line have been triggered
        if (this._triggerNewLine) {
          this._currentLine++;          
          if (this.mode === 'scroll') this._scrollEditor();
          if (this.mode === 'page') this._updatePage();
          this._triggerNewLine = false;
        }
        
        if (this._cursor().classList.contains('backslash')) {
          // We need to wait the user press 'Enter' before advance the line number.
          // Because if is press the wrong key, we will stay on the same line...
          this._triggerNewLine = true;
        } else {
          this._triggerNewLine = false;
        }
      }
      
      _backwardOneCharacter() {
        this._i--;
        this._triggerNewLine = false;
        if (this._cursor().classList.contains('backslash')) {
          this._currentLine--;
          if (this.mode === 'scroll') this._scrollEditor();          
        }
      }
      
      // Scroll to position the current line on screen 
      // For performance reason, this method only need to call after each newline character.
      _scrollEditor() {
        console.log('[typio-editor] Scroll to show line ' + this._currentLine);
        if (this._currentLine > 5 && this._currentLine < this.numberLines - 5) { // do not scroll too soon. Wait for some lines.
          this._scrollToLine(this._currentLine - 5);
        } 
      }
      
      // Update the editor to display the current page.
      _updatePage() {
        const numberLinesPrintable = countLines(this.$.editor);
        const numberLinesTotal = this.numberLines;
        console.log('currentLine=', this._currentLine, ' numberLinesPrintable=', numberLinesPrintable);
        
        const pageNumber = parseInt(this._currentLine / numberLinesPrintable) + 
          ((this._currentLine % numberLinesPrintable == 0) ? 0 : 1); // + 1 if remainder
        const numberLinesToScroll = (pageNumber > 1) ? (pageNumber - 1) * numberLinesPrintable : 0;
        
        console.log('[typio-editor] Scroll to page ' + pageNumber + ' by shifting ' + numberLinesToScroll + ' lines');
        this._scrollToLine(numberLinesToScroll);
      }
      
      // Scroll to position the given line at the top of the editor.
      // For performance reason, this method only need to call after each newline character.
      _scrollToLine(lineNumber) {
        this.$.editor.style.marginTop = lineNumber * -1.5 + 'em'; // see #editor line-height property
      }
      

      _allowToEnd() {
        return this._error == false || this.continueOnErrors;
      }

      end() {
        this.$.stats.stopTimer();
        this.$.editor.classList.add('highlight-mistyping');
        this.ended = true;
        this.dispatchEvent(new CustomEvent('endOfInput', {detail: {length: this._length}}));
      }


      // Utility methods to manipulate current character

      _cursor() {
        return this._characters[this._i];
      }

      _isIgnorable() {
        let character = this._cursor();
        return character.classList.contains('ignorable');
      }

      _isEndOfFile() {
        return this._i + 1 >= this._length;
      }

      _highlight() {
        let character = this._cursor();
        character.classList.remove('char-invalid');
        character.classList.add('char-active');
        character.classList.add('disabled');
      }

      _unhighlight() {
        let character = this._cursor();
        character.classList.remove('char-active');
        character.classList.remove('char-invalid');
        character.classList.add('disabled');
      }

      listenChartEvents() {
        if (!this._chartEventsListened) {
          google.visualization.events.addListener(this.$.chart._chart, 'select', () => {
            let selection = this.$.chart._chart.getSelection();
            if (selection.length) {
              this.selectInterval(selection[0].row);
            }
          });
          this._chartEventsListened = true;
        }
      }

      selectInterval(column) {
        if (this.$.editor.classList.contains('highlight-interval-' + column)) {
          // unselect
          this.$.editor.classList.remove('highlight-interval-' + column);
        } else {
          // unselect all
          for (let i = 0; i < this.$.stats.intervalNumber; i++) {
            this.$.editor.classList.remove('highlight-interval-' + i);
          }
          // and select the selected one
          this.$.editor.classList.add('highlight-interval-' + column);
        }

      }

      //
      // Navigation
      //

      _toggleDrawer() {
        this.$.drawer.toggle();
      }

    }
    window.customElements.define(TypioEditor.is, TypioEditor);

    /* Determine the number of text lines inside an HTML element. */
    function countLines(element) {
      // see https://stackoverflow.com/questions/8606588/how-to-get-the-line-height-of-a-span?rq=1
      let style = window.getComputedStyle(element);
      let divHeight = element.offsetHeight;
      let lineHeight = parseInt(style.lineHeight);
      return parseInt(divHeight / lineHeight);
    }

  </script>
</dom-module>
