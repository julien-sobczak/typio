<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/polymer/lib/utils/flattened-nodes-observer.html">

<link rel="import" href="/src/typio-app/shared-styles.html">
<link rel="import" href="/src/typio-app/typio-viewer.html">

<dom-module id="typio-editor">

  <script>

    /**
     * Editor screen (where text to type is displayed).
     *
     * @customElement
     * @polymer
     */
    class TypioEditor extends TypioViewer {

      static get is() { return 'typio-editor'; }
      static get properties() {
        return {

          //
          // + typio-viewer properties
          //

          // Override
          controls: {
            type: Boolean,
            value: false
          },

          /**
           * Let the user continues typing when an error occurs.
           * If false, the session will not end until all characters are valid.
           */
          continueOnErrors: {
            type: Boolean,
            value: false
          },


          //
          // State management
          //

          initialized: {
            type: Boolean,
            value: false
          },

          paused: {
            type: Boolean,
            value: false
          },

          started: {
            type: Boolean,
            value: false
          },

          ended: {
            type: Boolean,
            value: false
          },


          //
          // Error management
          //

      	  /**
      	   * True only when the user has mistyped.
      	   * False when the typo is fixed.
      	   */
          error: {
      	    type: Boolean,
      	    value: false
      	  },

          /**
           * The position where the error is located. (0-based index)
           * Returns `undefined` if `error` is false.
           */
          positionError: {
            type: Number,
            value: undefined
          },


          //
          // Editor inner working properties
          //

          // The index of the latest valid entered character
          _countValid: {
            type: Number,
            value: 0
          },

        };
      }

      ready() {
        super.ready();
        this.reset();
        this._addKeysListeners();
      }

      /**
       * Called this method to reset the editor (ex: retry).
       */
      reset() {
        super.reset();

        // reset editor styles
        this.unhighlightAll();
        this.unannotateAll('disabled');
        this.unannotateGlobal('error');
        this.hideMispellings();

        // reset variables
        this.error = false;
        this.positionError = undefined;
        this._countValid = 0;

        // reset ready-screen
        this.initialized = false;
        this.started = false;
        this.paused = false;
        this.ended = false;
      }

      _removeKeysListeners() {
        if (this._keydownListener) {
          document.removeEventListener('keydown', this._keydownListener);
        }
        if (this._keyupListener) {
          document.removeEventListener('keyup', this._keyupListener, false);
        }
        if (this._keypressListener) {
          document.removeEventListener('keypress', this._keypressListener, false);
        }
      }


      /*
      MacOS key sequence
      editor:136 keydown KeyboardEvent {isTrusted: true, key: "Shift", code: "ShiftLeft", location: 1, ctrlKey: false, …}
      editor:136 keydown KeyboardEvent {isTrusted: true, key: "Dead", code: "Quote", location: 0, ctrlKey: false, …}
      editor:136 keyup KeyboardEvent {isTrusted: true, key: "Dead", code: "Quote", location: 0, ctrlKey: false, …}
      editor:136 keyup KeyboardEvent {isTrusted: true, key: "Shift", code: "ShiftLeft", location: 1, ctrlKey: false, …}
      editor:136 keydown KeybocardEvent {isTrusted: true, key: " ", code: "Space", location: 0, ctrlKey: false, …}
      editor:136 keypress KeyboardEvent {isTrusted: true, key: " ", code: "Space", location: 0, ctrlKey: false, …}
      editor:136 keyup KeyboardEvent {isTrusted: true, key: " ", code: "Space", location: 0, ctrlKey: false, …}
      */

      _addKeysListeners() {
        // We listen for tab character (match any number of consecutive characters)
        this._keydownListener = event => {
          //console.log('keydown', event);
          if (!this.started || this.ended || event.ctrlKey) return;
          if (event.key !== 'Tab') return; // we are only interested by tabular character
          event.preventDefault();
          event.stopPropagation();
          this._checkInput(event.code, event.key);
          return false;
        };
        document.addEventListener('keydown', this._keydownListener);

        // We listen keyup for nonprintable characters
        this._keyupListener = event => {
          //console.log('keyup', event);
          if (!this.started || this.ended || event.ctrlKey) return;
          if (event.key === 'Dead') {
            this._deadKeyActive = true;
            this_.deadKeyName = event.key;
          }
          if (event.key === 'Backspace') {
            this.backward();
          }
        };
        document.addEventListener('keyup', this._keyupListener, false);

        // ... and keypress for printable ones (keypress support dead keys)
        this._keypressListener = event => {
          //console.log('keypress', event);
          if (!this.started || this.ended) return;

          const keyName = event.key;

          if (this._deadKeyActive) {
            event = this._deadEvent;
            this._deadKeyActive = false;
            keyName = event.code; // "Quote"
          }

          if (keyName === 'Control') {
            // not alert when only Control key is pressed.
            return;
          }

          if (event.ctrlKey) {
            // Even though event.key is not 'Control' (i.e. 'a' is pressed),
            // event.ctrlKey may be true if Ctrl key is pressed at the time.
            ;
          } else {
            this._checkInput(event.code, keyName);
            event.preventDefault();
            return false;
          }
        };
        document.addEventListener('keypress', this._keypressListener, false);
      }

      /**
       * Called when the user has validated the ready screen.
       */
      start() {
        console.debug('[typio-core-editor] start with', this._content);
        this.initialized = true;
        this.started = true;
        this.numberLines = this._content.split('\n').length;

        // refresh the viewer
        super.refresh();

        this.initialized = true;
        this.annotateAll('disabled');
        this.advance();
      }

      cancel() {
        console.log('[typio-editor] cancelled');
        this.ended = true;
      }

      /**
       * Pause the practice session.
       */
      resume() {
        if (this.started) this.paused = true;
      }

      /**
       * Marks the end of the typing session.
       */
      end() {
        this.ended = true;
        this.dispatchEvent(new CustomEvent('typing-ended', {detail: {length: this._length}}));
      }

      /**
       * Called after each key press.
       */
      _checkInput(keyCode, keyName) {
        if (!this.started || this.paused || this.ended) {
          // ignore input outside practice sessions
          return;
        }

        if (this.paused) {
          this.resume();
        }

        const startTime = performance.now();

        let valid = undefined;
        let position = this.position;
        let character = this.character();
        let line = this._currentLine;

        let shouldAdvance = false;

        if (this.debug) {
          console.log('Expected: [' + this.character() + '] (' + this.character().charCodeAt(0) + '), Got: [' + keyName + '] (' + keyName.charCodeAt(0) + '), valid=' + this._isValid(this.element(), keyName) + ', position=' + this.position + ', error=' + this.error + ', positionError=' + this.positionError);
        }

        // Allow optional character to be passed
        if (this.hasAnnotation('optional') &&
              !this._isValid(this.element(), keyName) &&
               this._isValid(this._nextNonIgnorableElement(), keyName)) {
          this.advance();
        }

        if (keyName === 'Tab' && this._canAdvance()) {
          // advance to the next nonspace character
          while (this.hasAnnotation('space')) {
            this.advance();
          }

        } else if (this._isValid(this.element(), keyName)) {
          valid = true;
          this.unannotate('disabled');

          if (this.error && this.positionError == this.position) {
            console.log('[bug] remove error');
            this.unannotate('char-invalid', 'wrong');
            this.error = false;
            this.positionError = undefined;
          }

          if (this.continueOnErrors) {
            this.unannotate('char-invalid');
          } else if (this.error && !this.continueOnErrors) {
            this.annotate('char-invalid');
          } else {
	          this.unannotate('char-invalid');
	        }

          // Add marker to highlight mistyping at the end
          if (!this.hasAnnotation('wrong') && !this.hasAnnotation('useless')) {
            this.annotate(this.error ? 'useless' : 'right');
          }

          if (!this.error) {
            this._countValid++;
          }
          shouldAdvance = true;

        } else {
          valid = false;
          this.error = true;
          this.positionError = this.position;
          this.annotate('char-invalid', 'wrong');
          this.annotateGlobal('error');
          shouldAdvance = true;
        }

        // Notify about entered input
        let accepted = valid || this.continueOnErrors;
        let detail = {
          "index": position,
          "indexValid": this._countValid,
          "line": line,
          "character": TypioEditor.keyNameToChar(character),
          "keyName": keyName,
          "keyCode": keyCode,
          "valid": valid,
          "accepted": accepted,
        }
        this.dispatchEvent(new CustomEvent('character-entered', {detail: detail, bubbles: true, composed: true}));

        if (shouldAdvance) {
          this.advance();
        }

        if (this.profile) {
          console.log('[typio-editor] checking input done in ' + (performance.now() - startTime) + 'ms');
        }
      }

      _isValid(character, keyName) {
        if (character == undefined) return false;

        const expectedCharacter = character.dataset.text;

        // nominal case
        if (keyName === expectedCharacter) {
          return true;
        }

        // Manage exceptions:

        // Curved quotes are not typeable => allow simple quote
        if (keyName === "'" && (expectedCharacter === '‘' || expectedCharacter === '’')) {
          return true;
        }
        if (keyName === '"' && (expectedCharacter === '“' || expectedCharacter === '”')) {
          return true;
        }

        // Allow space for some indentation characters
        if (keyName === ' ' && this.hasAnnotationElement(character, "allowSpace")) {
          return true;
        }

        // Nothing matches
        return false;
      }

      /**
       * Move backward to the previous editable character.
       */
      backward(n = 1) {
        if (this.position == 0) return;

        for (let i = 0; i < n; i++) {

          if (this.position == 0) break; // Do nothing if at start

          do {
            this._unselect();
            this._backwardOneCharacter();

            if (this.error && this.position === this.positionError) {
              this.error = false;
              this.positionError = undefined;
              this.unannotateGlobal('error');
              this.unannotate('char-invalid', 'wrong');
            }
          } while (this.hasAnnotation('ignorable') && this.position > 0);
        }

        if (this.hasAnnotation('ignorable')) { // Oops, we are on an ignorable character
          this.advance();
        }

        if (this.position >= 0) {
          this._select();
        }
      }

      /**
       * Move forward to the next editable character.
       */
      advance() {
        if (this.position >= 0) {
          this.unannotate('char-active');
        }

        if (this.endOfFile()) {
          // Do not trigger end if there is error, except if allowed
          if (this._allowToEnd()) {
            this.end();
          }
          return;
        }

        this._advanceOneCharacter();
        while (!this.endOfFile() && this.hasAnnotation('ignorable')) { this._advanceOneCharacter(); }
        this._select();
      }

      _canAdvance() {
        return !this.error || this.continueOnErrors;
      }

      /**
       * Move backward to the previous character (editable or not editable.)
       */
      _advanceOneCharacter() {
        this.position++;

        // Check if a new line have been triggered
        if (this._triggerNewLine) {
          this._currentLine++;
          if (this.debug) console.log("Triggering new line...", this.mode);
          // FIXME what to do instead?
          //if (this.mode === 'scroll') this._scrollEditor();
          //if (this.mode === 'page') this._updatePage();
          this._triggerNewLine = false;
        }

        if (this.hasAnnotation('backslash')) {
          // We need to wait the user press 'Enter' before advance the line number.
          // Because if is press the wrong key, we will stay on the same line...
          this._triggerNewLine = true;
        } else {
          this._triggerNewLine = false;
        }
      }

      /**
       * Move forward to the next character (editable or not editable.)
       */
      _backwardOneCharacter() {
        this.position--;
        this._triggerNewLine = false;
        if (this.hasAnnotation('backslash')) {
          this._currentLine--;
          // FIXME what to do instead?
        }
      }

      /**
       * Have we reached the end of text?
       */
      _allowToEnd() {
        return this.error == false || this.continueOnErrors;
      }

      _select() {
        this.unannotate('char-invalid');
        this.annotate('char-active', 'disabled');
      }

      _unselect() {
        this.unannotate('char-active', 'char-invalid');
        this.annotate('disabled');
      }

      showMispellings() {
        this.annotateGlobal('highlight-mistyping');
        this.controls = true;
      }

      hideMispellings() {
        this.unannotateGlobal('highlight-mistyping');
        this.controls = false;
      }

      /**
       * Return the next character which doesn't have the `ignorable` annotation.
       */
      _nextNonIgnorableElement() {
        let i = this.position + 1;
        while (true) {
          if (this.endOfFile()) return undefined;
          let element = this.elementAt(i++);
          if (!this.hasAnnotationElement(element, 'ignorable')) {
            return element;
          }
        }
      }

      static keyNameToChar(keyName) {
        if (keyName === 'Enter') return '\n';
        // Add specific cases here
        return keyName;
      }

      /**
       * Conenience method returns corresponding value for given keyName or keyCode.
       *
       * @param {Mixed} keyCode {Number} or keyName {String}
       * @return {Number}
       */
      static keyNameToCode(keyName) {
        // Source: http://jsfiddle.net/vWx8V/
        // http://stackoverflow.com/questions/5603195/full-list-of-javascript-keycodes

        if (!TypioEditor.keyNameToCode.codes) {
          // populate dictionary

          var codes = exports.code = exports.codes = {
            'backspace': 8,
            'tab': 9,
            'enter': 13,
            'shift': 16,
            'ctrl': 17,
            'alt': 18,
            'pause/break': 19,
            'caps lock': 20,
            'esc': 27,
            'space': 32,
            'page up': 33,
            'page down': 34,
            'end': 35,
            'home': 36,
            'left': 37,
            'up': 38,
            'right': 39,
            'down': 40,
            'insert': 45,
            'delete': 46,
            'command': 91,
            'left command': 91,
            'right command': 93,
            'numpad *': 106,
            'numpad +': 107,
            'numpad -': 109,
            'numpad .': 110,
            'numpad /': 111,
            'num lock': 144,
            'scroll lock': 145,
            'my computer': 182,
            'my calculator': 183,
            ';': 186,
            '=': 187,
            ',': 188,
            '-': 189,
            '.': 190,
            '/': 191,
            '`': 192,
            '[': 219,
            '\\': 220,
            ']': 221,
            "'": 222
          }

          // Helper aliases

          var aliases = exports.aliases = {
            'windows': 91,
            '⇧': 16,
            '⌥': 18,
            '⌃': 17,
            '⌘': 91,
            'ctl': 17,
            'control': 17,
            'option': 18,
            'pause': 19,
            'break': 19,
            'caps': 20,
            'return': 13,
            'escape': 27,
            'spc': 32,
            'spacebar': 32,
            'pgup': 33,
            'pgdn': 34,
            'ins': 45,
            'del': 46,
            'cmd': 91
          }

          /*!
           * Programatically add the following
           */

          // lower case chars
          for (i = 97; i < 123; i++) codes[String.fromCharCode(i)] = i - 32

          // numbers
          for (var i = 48; i < 58; i++) codes[i - 48] = i

          // function keys
          for (i = 1; i < 13; i++) codes['f'+i] = i + 111

          // numpad keys
          for (i = 0; i < 10; i++) codes['numpad '+i] = i + 96

          // Add aliases
          for (var alias in aliases) {
            codes[alias] = aliases[alias]
          }

          TypioEditor.keyNameToCode.codes = codes;
        }

        const codes = TypioEditor.keyNameToCode.codes;

        // check codes
        var foundNamedKey = codes[keyName.toLowerCase()]
        if (foundNamedKey) return foundNamedKey

        // check aliases
        var foundNamedKey = aliases[keyName.toLowerCase()]
        if (foundNamedKey) return foundNamedKey

        // weird character?
        if (keyName.length === 1) return keyName.charCodeAt(0)

        return undefined
      }

    }
    window.customElements.define(TypioEditor.is, TypioEditor);

  </script>
</dom-module>
