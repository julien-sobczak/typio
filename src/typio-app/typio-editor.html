<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/polymer/lib/utils/flattened-nodes-observer.html">
<link rel="import" href="../../bower_components/paper-toggle-button/paper-toggle-button.html">
<link rel="import" href="../../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../bower_components/google-chart/google-chart.html">
<link rel="import" href="../../bower_components/paper-fab/paper-fab.html">
<link rel="import" href="../../bower_components/iron-icons/maps-icons.html">

<link rel="import" href="/src/typio-app/typio-ready-screen.html">
<link rel="import" href="/src/typio-app/typio-stats.html">
<link rel="import" href="/src/typio-app/typio-parser.html">
<link rel="import" href="/src/typio-app/typio-keyboard.html">
<link rel="import" href="/src/typio-app/typio-hands.html">
<link rel="import" href="/src/typio-app/shared-styles.html">

<dom-module id="typio-editor">
  <template>

    <!-- Stylesheet will be switched according the theme -->
    <link id="prismStylesheet" href="/css/prism-light.css" href$="/css/prism-{{theme}}.css" rel="stylesheet">

    <style include="shared-styles">

      :host {
        display: block;
      }

      #screen {
        height: 100%;
        color: black;
      }

      /* Theme management */
      #screen.theme-dark {
        background: #272822;
        color: white;
      }


      #pageControls {
        display: none;
      }
      #screen.ended-true #pageControls {
        position: fixed;
        display: block;
        bottom: 25px;
        left: 50%;
        width: 300px;
        margin-left: -150px;
        z-index: 200;
      }


      /*
       * Statistics panel
       */

      #stats {
        position: fixed;
        top: 0;
        right: 0;
        padding: 1in;
        transition: width 0.5s, height 0.5s;
      }

      #chart {
        display: none;
        /*
          There is a bug that displays:
            'TypeError: cannot read property 'draw' of null'
          on load time during a short time before showing the chart correctly.

          As a hack, we hide the chart until the last moment.
          At this time, the error message was already printed
          and we can reveal the chart.
         */
        height: 200px;
        width: 100%;
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        z-index: 100;
      }
      #screen.started-true #chart {
        display: block;
      }

      /* Support option "Show Chart" */
      #screen.showChart-false #chart,
      #screen.showChart-true.ended-true #chart {
        display: none !important;
      }
      #screen.showChart-true #chart {
        display: block !important;
      }


      /*
       * Mini chart
       */
      #minichart {
        display: none;
        position: fixed;
        height: 200px;
        width: 250px;
        top: 150px;
        left: 50px;
      }

      /* Displayed only when session is over. */
      #screen.ended-true #minichart {
        display: block !important;
      }
      
      /*
       * Heatmap
       */
       
      #heatmap {
        position: fixed;
        height: 100%;
        width: 100%;
        background-color: rgba(255,255,255,0.8);
        display: none; /* Only revealed after a practice session */
        z-index: 500;
      }
      #heatmap #keyboard {
        position: absolute;
        top: 50%;
        left: 50%;
        /* Using default size, the compact keyboard measures 576px x 192px */
        margin-top: calc(-1 * 192px / 2);
        margin-left: calc(-1 * 576px / 2);
      }
      #heatmap #hands {
        position: absolute;
        bottom: 0;
        left: 50%;
        margin-left: calc(-1 * 576px / 2);
      }
      
      #heatmap paper-icon-button {
        position: absolute;
        bottom: 1in;
        right: 1in;
      }


    

      #resourceName {
        position: fixed;
        top: 17px;
        height: 30px;
        left: 50%;
        width: 650px;
        margin-left: -250px;
        padding: 5px 25px;
        color: white;
        background: rgba(0, 0, 0, 0.5);
        z-index: 150;
        text-align: center;
        border-radius: 15px;
        overflow: hidden;
      }


      #screen.initialized-false {
        display: none;
      }
      #screen.initialized-true {
        display: block;
      }
      
      #screen.ended-false #fabHeatmap { display: none;  }
      #screen.ended-true  #fabHeatmap { display: block; }
      
      #screen.ended-false #fabRestart { display: none;  }
      #screen.ended-true  #fabRestart { display: block; }

    </style>

    <typio-ready-screen id="readyScreen"
        type="[[type]]"
        language="[[language]]"
        content="[[content]]"
        ignore-comments="{{settings.ignoreComments}}"
        ignore-indents="{{settings.ignoreIndents}}"
        continue-on-errors="{{settings.continueOnErrors}}"
        show-chart="{{settings.showChart}}"
        mode="{{settings.mode}}"
        on-ready="start">
    </typio-ready-screen>

    <typio-parser id="parser"
        type="[[type]]"
        language="[[language]]"
        content="[[_content]]"
        ignore-comments="[[settings.ignoreComments]]"
        ignore-indents="[[settings.ignoreIndents]]"
        ignore-module-declarations="[[settings.ignoreModuleDeclarations]]">
    </typio-parser>

    <div id="screen" class$="initialized-[[initialized]] showChart-{{showChart}} mode-{{mode}} started-{{started}} ended-{{ended}} theme-{{theme}}">

      <template is="dom-if" if="{{resource}}">
        <div id="resourceName">
          <strong>[[resource]]</strong> | [[resourceItem]]
        </div>
      </template>

      <div class="fabs">
        <paper-fab id="fabHeatmap" icon="maps:map" title="Heatmap" on-click="showHeatmap"></paper-fab>
        <paper-fab id="fabRestart" icon="autorenew" title="Restart" on-click="restart"></paper-fab>
      </div>
      
      <typio-stats id="stats"></typio-stats>

      <typio-core-editor id="editor" 
          data-type$="[[type]]" 
          data-theme$="[[theme]]" 
          data-mode$="[[mode]]" 
          data-content$="[[_content]]"
          on-character-entered="_characterEntered"
          on-typing-ended="_typingEnded">
      </typio-core-editor>
      
      <div id="pageControls">
        <paper-icon-button on-click="_moveToFirstPage" icon="first-page"></paper-icon-button>
        <paper-icon-button on-click="_moveToPreviousPage" icon="chevron-left"></paper-icon-button>
        <paper-icon-button on-click="_moveToNextPage" icon="chevron-right"></paper-icon-button>
        <paper-icon-button on-click="_moveToLastPage" icon="last-page"></paper-icon-button>
      </div>
      
      <div id="heatmap">
        <typio-keyboard id="keyboard" mixed-cases></typio-keyboard>
        <typio-hands id="hands"></typio-hands>
        <div class="fabs">
          <paper-fab id="fabHeatmap" icon="close" title="Close" on-click="hideHeatmap"></paper-fab>
        </div>
      </div>

      <google-chart id="chart" class$="showChart-{{showChart}}"
        type="stepped-area"
        options="[[chartOptions]]"
        cols="[[chartCols]]"
        rows='[]'>
      </google-chart>

      <google-chart id="minichart"
        type="stepped-area"
        options="[[chartOptions]]"
        cols="[[chartCols]]"
        rows='[]'>
      </google-chart>

    </div>

  </template>

  <script>

    /**
     * Editor screen (main screen of the application).
     *
     * @customElement
     * @polymer
     */
    class TypioEditor extends Polymer.Element {

      static get is() { return 'typio-editor'; }
      static get properties() {
        return {

          /**
           * The type of content (code, literature).
           */
          type: {
            type: String,
            value: "code"
          },

          /**
           * Language of the content.
           *
           * Could be a programming language (Java, Python) or a
           * spoken language (French, English).
           *
           * Note: Case is not important.
           */
          language: {
            type: String,
            value: "Python"
          },

          /**
           * The name of the resource where the content is extracted.
           * Could be a book title or a Github project name.
           */
          resource: {
            type: String,
            value: null
          },

          /**
           * A reference to idemtity the content inside the resource.
           * Could be a chapter title, or a file path.
           */
          resourceItem: {
            type: String,
            value: null
          },

          /**
           * The content to touch type.
           *
           * This property should be set in JavaScript and
           * not through an HTML attribute to avoid HTML escaping (&lt; for <).
           */
          content: {
            type: String,
            value: 'import sys\n\ndef main():\n  print("Hello World")\n  sys.exit(0)\n',
            observer: '_contentChanged'
          },

          /**
           * Array(Boolean) Return true for element `i`
           * if the ith line in `_content` is a logical line
           * or the start of a logical line.
           */
          _logicalLines: {
            type: Array,
            value: null
          },

          /**
           * Settings
           */
          settings: {
            type: Object,
            value: {
              ignoreComments: true,
              ignoreIndents: true,
              continueOnErrors: false,
              ignoreModuleDeclarations: true,
              showChart: true,
              theme: 'light',
              mode: 'scroll'
            }
          },

          /**
           * Editor code style.
           * Name should match a CSS resource name /css/prism-{{theme}}.css.
           */
          theme: {
            type: String,
            value: 'light'
          },


          /*
           * State management
           */

          /** True as soon as everything is ready for the user to start typing. */
          initialized: {
            type: Boolean,
            value: false
          },
          
          /** True as soon as the user had pressed his first key. */
          started: {
            type: Boolean,
            value: false
          },

          paused: {
            type: Boolean,
            value: true
          },

          ended: {
            type: Boolean,
            value: false
          },


          //
          // Google Chart Configuration
          // See https://developers.google.com/chart/interactive/docs/gallery/steppedareachart
          //

          chartOptions: {
            type: Object,
            readOnly: true,
            value: {
              "backgroundColor": { fill:'transparent' },
              "title": "WPM",
              "legend": "none",
              "fontName": "Cutive",
              "areaOpacity": 1,
              "tooltip": {"trigger": "none"},
              "chartArea": {
                "left": 0,
                "top": 0,
                "width": "100%",
                "height": "100%",
                "backgroundColor": {"strokeWidth": 0}
              },
              "hAxis": { "textPosition": "in", "textStyle": { "color": "black", "bold": true, "auraColor": "none" } },
              "vAxis": {
                "textPosition": "int",
                "minValue": 0,
                "maxValue": 200,
                "gridlines": { "count": 0 }
              },
              "colors": ["#009ee3"],
              "lineWidth": 2,
              "annotations": {"textStyle": { "color": "orange"} }
            }
          },

          chartCols: {
            type: Array,
            readOnly: true,
            value: [
              {"label": "Progress", "type": "string"},
              {"label": "WPM",      "type": "number"},
              {"type": "string",    "role": "annotation"},
              {"type": "string",    "role": "style"}
              // see https://developers.google.com/chart/interactive/docs/roles?hl=en for the role property of columns
            ]
          },


        };
      }

      ready() {
        super.ready();
      }
      
      restart() {
        this.reset();
      }

      /**
       * Called this method to reset the editor (ex: retry).
       */
      reset() {
        // Reset variables
        this.$.stats.reset();
        this.$.editor.reset();

        // Reset globals
        this.initialized = false;
        this.started = false;
        this.paused = true;
        this.ended = false;

        // Reset ready-screen
        this.$.readyScreen.hidden = false;
      }

      _contentChanged() {
        const result = TypioParser.preprocess(this.content);
        this._content = result.preprocessedContent;
        this._logicalLines = result.logicalLines;
      }

      /**
       * Called when the user has validated the ready screen.
       */
      start(e, detail) {
        // Collect selected content
        const result = TypioParser.preprocess(detail.selection);
        this._logicalLines = result.logicalLines;

        // Determine settings
        this.settings.ignoreComments = detail.ignoreComments;
        this.settings.ignoreModuleDeclarations = detail.ignoreModuleDeclarations;
        this.settings.ignoreIndents = detail.ignoreIndents;
        this.showChart = detail.showChart;
        this.theme = detail.theme;
        this.mode = detail.mode;
        this.initialized = true;
        
        this.$.parser.content = result.preprocessedContent;
        this.$.parser.ignoreComments = this.settings.ignoreComments;
        this.$.parser.ignoreIndents = this.settings.ignoreIndents;
        this.$.parser.ignoreModuleDeclarations = this.settings.ignoreModuleDeclarations;
        this.$.parser.parse();
        
        this.$.stats.editableCharacters = this._calculateEditableCharacters(result.preprocessedContent, this.$.parser.classes);
        
        this.$.editor.content = result.preprocessedContent;
        this.$.editor.classes = this.$.parser.classes;
        this.$.editor.intervals = this.$.stats.intervals;
        this.$.editor.logicalLines = result.logicalLines;
        this.$.editor.continueOnErrors = detail.continueOnErrors;
        
        console.log('Launching editor...');
        this.$.editor.start();
      }

      _calculateEditableCharacters(content, classes) {
        const len = content.length;
        let editableCharacters = new Array(len);
        for (let i = 0; i < len; i++) {
          editableCharacters[i] = !classes[i].includes('ignorable');
        }
        return editableCharacters;
      }

      _characterEntered(e, detail) {
        // Update stats
        if (detail.indexValid <= 1) { // First character entered?
          this.$.stats.resumeTimer();
          this.started = true;
        }
        this.$.stats.newCharacter(detail.character, detail.keyName, detail.valid, detail.accepted);

        // Update charts
        this.$.chart.style.display = 'block !important';
        this.$.chart.rows = this.$.stats.wpmPerInterval();
        this.$.chart.redraw();
      }

      _typingEnded() {
        this.ended = true;
        this.$.stats.stopTimer();
        this._updateMinichart();
        this.$.editor.showMispellings();
        this.$.editor.moveToFirstPage();
      }

      _updateMinichart() {
        this.$.minichart.rows = this.$.stats.wpmPerInterval();
        for (let i = 0; i < this.$.minichart.rows.length; i++) {
          this.$.minichart.rows[i][2] = ''; // remove annotations
        }
        this.$.minichart.redraw();
        this.listenChartEvents();
      }

      /**
       * Let user click on the histogram to select a bar
       * and focus the corresponding text.
       */
      listenChartEvents() {
        if (!this._chartEventsListened) {
          google.visualization.events.addListener(this.$.minichart._chart, 'select', () => {
            let selection = this.$.minichart._chart.getSelection();
            if (selection.length) {
              this.$.editor.selectInterval(selection[0].row);
            }
          });
          this._chartEventsListened = true;
        }
      }
      
      // 
      // Page controls
      //
      
      _moveToFirstPage() {
        this.$.editor.moveToFirstPage();
      }
      _moveToPreviousPage() {
        this.$.editor.moveToPreviousPage();
      }
      _moveToNextPage() {
        this.$.editor.moveToNextPage();
      }
      _moveToLastPage() {
        this.$.editor.moveToLastPage();
      }


      // 
      // Heatmap
      // 
      
      showHeatmap() {
        const responseTimes = this.$.stats.getResponseTimeKeys();
        const responseTimePerKey = new Map();
        let worstInMs = 0;
        responseTimes.forEach(keyStats => { 
          responseTimePerKey.set(keyStats.character, keyStats);
          if (keyStats.averageInMs > worstInMs) {
            worstInMs = keyStats.averageInMs;
          }
        });

        this.$.keyboard.colorize(c => {
          if (!responseTimePerKey.has(c)) return false;
          const stats = responseTimePerKey.get(c);
          
          // We compare the response time with the worst response time to determine the color
          // We only want to highlight the worse keys, even if the user is typing slowy every key.
          const ratio = Math.floor(stats.averageInMs * 100 / worstInMs / 10.1); // Note between 0 and 10 exclusive
          // close to 10 = reddish
          // close to 0 = yellowish
          
          const ignoreBelowRatio = 2;
          if (ratio < ignoreBelowRatio) return false; 
          
          // See https://material.io/guidelines/style/color.html#color-color-palette
          return 'var(--paper-red-' + ((ratio - ignoreBelowRatio) * 100) + ')';
        });
        
        
        const fingerRepartition = TypioKeyboard.fingersFromText(this._content);
        const maxFingerCount = Math.max(
          fingerRepartition.leftHand.littleFinger,
          fingerRepartition.leftHand.ringFinger,
          fingerRepartition.leftHand.middleFinger,
          fingerRepartition.leftHand.indexFinger,
          fingerRepartition.leftHand.thumb,
          fingerRepartition.rightHand.littleFinger,
          fingerRepartition.rightHand.ringFinger,
          fingerRepartition.rightHand.middleFinger,
          fingerRepartition.rightHand.indexFinger,
          fingerRepartition.rightHand.thumb,
        );
        this.$.hands.colorizeLeftHand({
          littleFinger: TypioEditor.dynamicRedColor(fingerRepartition.leftHand.littleFinger, maxFingerCount),
          ringFinger:   TypioEditor.dynamicRedColor(fingerRepartition.leftHand.ringFinger, maxFingerCount),
          middleFinger: TypioEditor.dynamicRedColor(fingerRepartition.leftHand.middleFinger, maxFingerCount),
          indexFinger:  TypioEditor.dynamicRedColor(fingerRepartition.leftHand.indexFinger, maxFingerCount),
          thumb:        TypioEditor.dynamicRedColor(fingerRepartition.leftHand.thumb, maxFingerCount),
        });
        this.$.hands.colorizeRightHand({
          littleFinger: TypioEditor.dynamicRedColor(fingerRepartition.rightHand.littleFinger, maxFingerCount),
          ringFinger:   TypioEditor.dynamicRedColor(fingerRepartition.rightHand.ringFinger, maxFingerCount),
          middleFinger: TypioEditor.dynamicRedColor(fingerRepartition.rightHand.middleFinger, maxFingerCount),
          indexFinger:  TypioEditor.dynamicRedColor(fingerRepartition.rightHand.indexFinger, maxFingerCount),
          thumb:        TypioEditor.dynamicRedColor(fingerRepartition.rightHand.thumb, maxFingerCount),
        });
        
        this.$.heatmap.style.display = 'block';
      }
      
      hideHeatmap() {
        this.$.heatmap.style.display = 'none';
      }   
      
      static dynamicPaperColor(paperColor, actualValue, maxValue) {
        if (actualValue === 0) {
          return 'inherit'; // let blank if no value
        }
        
        let paperValue = Math.floor(actualValue * 100 / maxValue / 10) * 100;
        if (paperValue > 900) {
          paperValue = 900;
        }
        
        return `var(--paper-${paperColor}-${paperValue})`;
      }
      
      static dynamicRedColor(actualValue, maxValue) {
        return TypioEditor.dynamicPaperColor('red', actualValue, maxValue);
      }

    }
    window.customElements.define(TypioEditor.is, TypioEditor);


  </script>
</dom-module>
