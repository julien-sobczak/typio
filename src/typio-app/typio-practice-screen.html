<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/polymer/lib/utils/flattened-nodes-observer.html">
<link rel="import" href="../../bower_components/paper-toggle-button/paper-toggle-button.html">
<link rel="import" href="../../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../bower_components/google-chart/google-chart.html">
<link rel="import" href="../../bower_components/paper-fab/paper-fab.html">
<link rel="import" href="../../bower_components/iron-icons/maps-icons.html">

<link rel="import" href="/src/typio-app/typio-ready-screen.html">
<link rel="import" href="/src/typio-app/typio-stats.html">
<link rel="import" href="/src/typio-app/typio-keyboard.html">
<link rel="import" href="/src/typio-app/typio-hands.html">
<link rel="import" href="/src/typio-app/typio-sleep-tracker.html">
<link rel="import" href="/src/typio-app/typio-editor.html">
<link rel="import" href="/src/typio-app/shared-styles.html">

<dom-module id="typio-practice-screen">
  <template>

    <style include="shared-styles">

      :host {
        display: block;
      }

      #screen {
        height: 100%;
        color: black;
      }

      /* Theme management */
      #screen.theme-dark {
        background: #272822;
        color: white;
      }
      
      /*
       * Editor
       */
       
      typio-editor {
        display: block;
        width: 1000px;
        margin: 0 auto;
        padding: 1cm;
        position: fixed;
        top: 80px;
        bottom: 50px;
        z-index: 40;
        left: 50%;
        margin-left: -500px; /* Half of the width */

        overflow-y: hidden;
        overflow-x: visible;
      }


      /*
       * Statistics panel
       */

      #statsPanel {
        position: fixed;
        top: 0;
        right: 0;
        padding: 1in;
        transition: width 0.5s, height 0.5s;
      }
      
      /*
       * Main chart
       */

      #chart {
        display: none;
        /*
          There is a bug that displays:
            'TypeError: cannot read property 'draw' of null'
          on load time during a short time before showing the chart correctly.

          As a hack, we hide the chart until the last moment.
          At this time, the error message was already printed
          and we can reveal the chart.
         */
        height: 200px;
        width: 100%;
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        z-index: 100;
      }
      #screen.started-true #chart {
        display: block;
      }

      /* Support option "Show Chart" */
      #screen.showChart-false #chart,
      #screen.showChart-true.ended-true #chart {
        display: none !important;
      }
      #screen.showChart-true #chart {
        display: block !important;
      }


      /*
       * Mini chart
       */
      #miniChart {
        display: none;
        position: fixed;
        height: 200px;
        width: 250px;
        top: 100px;
        left: 50px;
      }

      /* Displayed only when session is over. */
      #screen.ended-true #miniChart {
        display: block !important;
      }
      
      
      /*
       * Heatmap
       */
       
      #heatmap {
        position: fixed;
        height: 100%;
        width: 100%;
        background-color: rgba(255,255,255,0.95);
        display: none; /* Only revealed after a practice session */
        z-index: 500;
      }
      #heatmap #keyboard {
        position: fixed;
        bottom: 200px;
        left: 50%;
        /* Using default size, the compact keyboard measures 576px x 192px */
        margin-top: calc(-1 * 192px / 2);
        margin-left: calc(-1 * 576px / 2);
      }
      #heatmap #hands {
        position: fixed;
        bottom: 0;
        left: 50%;
        margin-left: calc(-1 * 576px / 2);
      }
      
      #heatmap paper-icon-button {
        position: absolute;
        bottom: 1in;
        right: 1in;
      }
      
      /* List of graphs displayed in heatmap */
      
      #steppedAreaChart {
        position: fixed;
        height: 150px;
        width: 250px;
        top: 150px;
        left: 50%;
        margin-left: -600px;
      }

      #heatmapChart {
        position: fixed;
        height: 150px;
        width: 250px;
        top: 150px;
        left: 50%;
        margin-left: -300px;
      }
      
      #scatterChart {
        position: fixed;
        height: 150px;
        width: 250px;
        top: 150px;
        left: 50%;
        margin-left: 0;
      }
      
      #lineChart {
        position: fixed;
        height: 150px;
        width: 250px;
        top: 150px;
        left: 50%;
        margin-left: 300px;
      }
      
      #mostDifficultWords {
        position: fixed;
        width: 500px;
        right: 0;
        bottom: 0;
      }

    

      #resourceName {
        position: fixed;
        top: 17px;
        height: 30px;
        left: 50%;
        width: 650px;
        margin-left: -250px;
        padding: 5px 25px;
        color: white;
        background: rgba(0, 0, 0, 0.5);
        z-index: 150;
        text-align: center;
        border-radius: 15px;
        overflow: hidden;
      }


      #screen.initialized-false {
        display: none;
      }
      #screen.initialized-true {
        display: block;
      }
      
      #screen.ended-false #fabHeatmap { display: none;  }
      #screen.ended-true  #fabHeatmap { display: block; }
      
      #screen.ended-false #fabRestart { display: block;  }
      #screen.ended-true  #fabRestart { display: block; }

      #screen.ended-false #fabRewind { display: block;  }
      #screen.ended-true  #fabRewind { display: none;  }
      
      #screen.paused-true #editorFabs { display: none; }

      /*
       * statistics
       */

       #statsPanel .elapsedTime {
         font-size: 12px;
         color: gray;
       }

       #statsPanel .wpm {
         font-weight: bold;
         font-size: 1.7em;
       }
       
       #statsPanel #table {
         margin-bottom: 25px;
       }

       #statsInProgress, 
       #statsFinished {
         display: none;
       }
       #screen.ended-false #statsInProgress {
         display: block;
       }
       #screen.ended-true #statsFinished {
         display: block;
       }

      ul#summary, ul#keys, ul#keyCombinations {
        list-style-type: none;
      }
      ul#summary li {
        margin: 10px 15px;
      }
      ul#keys li {
        display: inline-block;
      }
      .key {
        display: inline-block;
        height: 35px;
        width: 35px;
        padding: 10px 10px;
        text-align: center;
        color: white;
        font-family: var(--logo-font-family);
        background-color: var(--typio-bg-color);
        margin: 10px 15px;
        border-radius: 3px;
        box-shadow: 2px 2px gray;
      }
      
      
      /*
       * Sleep Dialog 
       */
       
      #pauseDialog {
        display: none;
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        background-color: var(--typio-bg-color);
        color: white;
        z-index: 300;
      }
      #screen.paused-true #pauseDialog {
        display: block;
      }
      #pauseDialog h1 {
        position: absolute;
        text-align: center;
        font-size: 250%;
        font-weight: bold;
        top: 40%;
        width: 100%;
      }

    </style>

    <!-- Configure the content -->
    <typio-ready-screen id="readyScreen"
        type="[[type]]"
        language="[[language]]"
        content="[[content]]"
        continue-on-errors="{{continueOnErrors}}"
        show-chart="{{showChart}}"
        mode="{{mode}}"
        on-ready="start">
    </typio-ready-screen>
    
    <!-- Get stats about practice session -->
    <typio-stats id="stats"></typio-stats>

    <typio-sleep-tracker id="sleepTracker" on-sleep-detected="_sleepDetected"></typio-sleep-tracker>

    <div id="screen" class$="initialized-[[initialized]] showChart-{{showChart}} mode-{{mode}} started-{{started}} paused-{{paused}} ended-{{ended}} theme-{{theme}}">

      <template is="dom-if" if="{{resource}}">
        <div id="resourceName">
          <strong>[[resource]]</strong> | [[resourceItem]]
        </div>
      </template>
      
      <div id="pauseDialog" class="theme-transparent">
        <h1><!-- Are you sleeping? --></h1>
        <div class="fabs">
          <paper-fab icon="autorenew" title="Restart" on-click="restart"></paper-fab>
          <paper-fab icon="av:play-arrow" title="Resume" on-click="_resumeClicked"></paper-fab>
        </div>
      </div>

      <div id="editorFabs" class="fabs">
        <paper-fab id="fabHeatmap" icon="maps:map" title="Heatmap" on-click="showHeatmap"></paper-fab>
        <paper-fab id="fabRewind" icon="av:replay-10" title="Rewind" on-click="rewind"></paper-fab>
        <paper-fab id="fabRestart" icon="autorenew" title="Restart" on-click="restart"></paper-fab>
      </div>
      
      <div id="statsPanel">
        <span id="statsInProgress" class="wpm">[[currentWpm]] WPM</span>
        
        <div id="statsFinished">
          <div>
            <span>WPM <strong>[[statsSummary.wpm]]</strong> in [[statsSummary.elapsedTimeInS]]s</span>
            <ul id="summary">
              <li>WPM if no error: [[statsSummary.theoricalWpm]]</li>
              <li>Total characters: [[statsSummary.totalCharacters]]</li>
              <li>Typeable characters: [[statsSummary.totalEditableCharacters]]</li>
              <li>Typed characters: [[statsSummary.enteredCharacters]]</li>
              <li>Unproductive keystroke overhead: [[statsSummary.unproductiveKeystrokeOverhead]]%</li>
            </ul>
          </div>
          <div>
            <span>Most difficult keys</span>
            <ul id="keys">
              <template is="dom-repeat" items="{{mostDifficultKeys}}">
              <li><span class="key" inner-h-t-m-l="[[item.character]]"></span><span class="elapsedTime">[[item.averageInMs]] ms</span></li>
              </template>
            </ul>
          </div>
          <div>
            <span>Most difficult key combinations</span>
            <ul id="keyCombinations">
              <template is="dom-repeat" items="{{mostDifficultKeyCombinations}}">
              <li><span class="key" inner-h-t-m-l="[[item.fromCharacter]]"></span> &rarr; <span class="key" inner-h-t-m-l="[[item.toCharacter]]"></span><span class="elapsedTime">[[item.averageInMs]] ms</span></li>
              </template>
            </ul>
          </div>
        </div>        
      </div>

      <typio-editor id="editor" 
          data-type$="[[type]]" 
          data-theme$="[[theme]]" 
          data-mode$="[[mode]]" 
          data-content$="[[_content]]"
          on-character-entered="_characterEntered"
          on-typing-ended="_typingEnded"
          paused$="[[paused]]">
      </typio-editor>
      
      <div id="heatmap">
        <typio-keyboard id="keyboard" mixed-cases></typio-keyboard>
        <typio-hands id="hands"></typio-hands>
        
        <google-chart id="steppedAreaChart"
          type="stepped-area"
          options="[[steppedAreaOptions]]"
          data="[[steppedAreaData]]">
        </google-chart>
        
        <google-chart id="heatmapChart"
          type="bar"
          options='[[heatmapOptions]]'
          data='[[heatmapData]]'>
        </google-chart>

        <google-chart id="scatterChart"
          type="scatter"
          options='[[scatterOptions]]'
          data='[[scatterData]]'>
        </google-chart>
        
        <google-chart id="lineChart"
          type="line"
          options='[[lineOptions]]'
          data='[[lineData]]'>
        </google-chart>
        
        <div id="mostDifficultWords">
          <span>Most difficult words</span>
          <table>
            <thead>
              <tr>
                <th>Text</th><th>WPM</th>
              </tr>
            </thead>
            <tbody>
            <template is="dom-repeat" items="{{mostDifficultWords}}">
              <tr>
                <td class="text" inner-h-t-m-l="[[item.word]]"></td><td>[[item.wpm]]</td>
              </tr>
            </template>
            </tbody>
          </table>
        </div>
        
        <div class="fabs">
          <paper-fab id="fabHeatmap" icon="close" title="Close" on-click="hideHeatmap"></paper-fab>
        </div>
      </div>

      <google-chart id="chart" class$="showChart-{{showChart}}"
        type="stepped-area"
        options="[[chartOptions]]"
        cols="[[chartCols]]"
        rows='[]'>
      </google-chart>

      <google-chart id="miniChart"
        type="stepped-area"
        options="[[minichartOptions]]"
        cols="[[chartCols]]"
        rows='[]'>
      </google-chart>
      
    </div>

  </template>

  <script>

    /**
     * Editor screen (main screen of the application).
     *
     * @customElement
     * @polymer
     */
    class TypioPracticeScreen extends Polymer.Element {

      static get is() { return 'typio-practice-screen'; }
      static get properties() {
        return {

          //
          // User settings
          //

          /**
           * The type of content (code, literature).
           */
          type: {
            type: String,
            value: "code"
          },

          /**
           * Language of the content.
           *
           * Could be a programming language (Java, Python) or a
           * spoken language (French, English).
           *
           * Note: Case is not important.
           */
          language: {
            type: String,
            value: "Python"
          },

          /**
           * The name of the resource where the content is extracted.
           * Could be a book title or a Github project name.
           */
          resource: {
            type: String,
            value: null
          },

          /**
           * A reference to idemtity the content inside the resource.
           * Could be a chapter title, or a file path.
           */
          resourceItem: {
            type: String,
            value: null
          },

          /**
           * The content to touch type.
           *
           * This property should be set in JavaScript and
           * not through an HTML attribute to avoid HTML escaping (&lt; for <).
           */
          content: {
            type: String,
            value: 'import sys\n\ndef main():\n  print("Hello World")  # Greeting message\n  sys.exit(0)\n',
            //value: 'var (\n  toto    string\n  spirou  boolean\n)\n',
            //value: 'this is a very very very very very very very very very very very very very very very very very long line'
          },


          //
          // Settings
          //
           
          /**
           * Allow user to continue typing when an error is detected.
           */
          continueOnErrors: {
            type: Boolean,
            value: false
          },
          
          /**
           * Show a real-time graph while user is typing.
           */
          showChart: {
            type: Boolean,
            value: true
          },
          
          /**
           * Editor code style.
           * Name should match a CSS resource name /css/prism-{{theme}}.css.
           */
          theme: {
            type: String,
            value: 'light'
          },
          
          
          // 
          // Display settings
          //
          
          /**
           * To improve latency when typing, we do not refresh the stats
           * after each key press. We use this variable to keep the last
           * position when the last refresh occured.
           */
          _lastPositionWhenRefresh: {
            type: Number,
            value: null,
          },
          

          //
          // State management
          //

          /** True as soon as everything is ready for the user to start typing. */
          initialized: {
            type: Boolean,
            value: false
          },
          
          /** True as soon as the user had pressed his first key. */
          started: {
            type: Boolean,
            value: false
          },

          paused: {
            type: Boolean,
            value: false
          },

          ended: {
            type: Boolean,
            value: false
          },


          //
          // Google Chart Configurations
          // See https://developers.google.com/chart/interactive/docs/gallery/steppedareachart
          //
          
          // stepped-area chart

          steppedAreaOptions: {
            type: Object,
            readOnly: true,
            value: {
              legend: "none",
              width: 250,
              height: 150,
              theme: 'maximized',
              backgroundColor: { fill: 'transparent' },
              fontName: "Cutive",
              areaOpacity: 1,
              tooltip: { trigger: "none" },
              chartArea: {
                backgroundColor: { strokeWidth: 0 }
              },
              hAxis: { textPosition: "in", textStyle: { color: "black", bold: true, auraColor: "none" } },
              vAxis: {
                textPosition: "in",
                minValue: 0,
                maxValue: 200,
                gridlines: { "count": 0 }
              },
              colors: ["#009ee3"],
              lineWidth: 2,
              annotations: { textStyle: { color: "orange"} }
            }
          },
          
          steppedAreaData: {
            type: Array,
            readOnly: true,
            value: undefined
          },
          
          chartOptions: {
            type: Object,
            readOnly: true,
            value: {
              backgroundColor: { fill:'transparent' },
              title: "WPM",
              legend: "none",
              fontName: "Cutive",
              areaOpacity: 1,
              tooltip: {trigger: "none"},
              chartArea: {
                left: 0,
                top: 0,
                width: "100%",
                height: "100%",
                backgroundColor: {strokeWidth: 0}
              },
              hAxis: { textPosition: "in", textStyle: { color: "black", bold: true, auraColor: "none" } },
              vAxis: {
                textPosition: "in",
                minValue: 0,
                maxValue: 200,
                gridlines: { "count": 0 }
              },
              colors: ["#009ee3"],
              lineWidth: 2,
              annotations: { textStyle: { color: "orange"} }
            }
          },
          
          minichartOptions: {
            type: Object,
            readOnly: true,
            value: {
              backgroundColor: { fill:'transparent' },
              title: "WPM",
              legend: "none",
              fontName: "Cutive",
              areaOpacity: 1,
              tooltip: {trigger: "none"},
              chartArea: {
                left: 0,
                top: 0,
                width: "100%",
                backgroundColor: {strokeWidth: 0}
              },
              hAxis: { textPosition: "out", textStyle: { color: "black", bold: true, auraColor: "none" } },
              vAxis: {
                textPosition: "in",
                minValue: 0,
                maxValue: 200,
                gridlines: { "count": 0 }
              },
              colors: ["#009ee3"],
              lineWidth: 2,
              annotations: { textStyle: { color: "orange"} }
            }
          },
          
          chartCols: {
            type: Array,
            readOnly: true,
            value: [
              {"label": "Progress", "type": "string"},
              {"label": "WPM",      "type": "number"},
              {"type": "string",    "role": "annotation"},
              {"type": "string",    "role": "style"}
              // see https://developers.google.com/chart/interactive/docs/roles?hl=en for the role property of columns
            ]
          },
          
          // heatmap chart
          
          heatmapOptions: {
            type: Object,
            readOnly: true,
            value: {
              orientation: 'horizontal',
              width: 250,
              height: 150,
              legend: { position: 'none' },
              bar: { groupWidth: '100%' },
              bars: 'horizontal',
              isStacked: 'percent',
              theme: 'maximized',
              colors: ["#009ee3"],
              vAxis: { 
                textPosition: 'none'
              },
              hAxis: {
                textPosition: 'none'
              },
              annotations: { textStyle: { color: "black"} },
              tooltip: { trigger: "none" },
            }
          },
          
          heatmapData: {
            type: Array,
            readOnly: true,
            value: undefined
          },
          
          // scatter chart
          
          scatterOptions: {
            type: Object,
            readOnly: true,
            value: {
              width: 250,
              height: 150,
              legend: { position: 'none' },
              theme: 'maximized',
              colors: ["#009ee3"],
              vAxis: { 
                textPosition: 'none'
              },
              hAxis: {
                textPosition: 'none'
              },
              tooltip: { textStyle: { bold: true, fontSize: '24px'} },
              annotations: { textStyle: { color: "black"} },
            }
          },
          
          scatterData: {
            type: Array,
            readOnly: true,
            value: undefined
          },
          
          // line chart
          
          lineOptions: {
            type: Object,
            readOnly: true,
            value: {
              width: 250,
              height: 150,
              legend: { position: 'none' },
              theme: 'maximized',
              colors: ["#009ee3"],
              vAxis: { 
                textPosition: 'none'
              },
              hAxis: {
                textPosition: 'none'
              },
              tooltip: { textStyle: { bold: true, fontSize: '24px'} },
              annotations: { textStyle: { color: "black"} },
            }
          },

          lineData: {
            type: Array,
            readOnly: true,
            value: undefined
          },
          
        };
      }

      restart() {
        this.reset();
      }

      /**
       * Called this method to reset the editor (ex: retry).
       */
      reset() {
        // Reset variables
        this.$.stats.reset();
        this.$.editor.reset();

        // Reset globals
        this.initialized = false;
        this.started = false;
        this.paused = false;
        this.ended = false;
        this._lastPositionWhenRefresh = 0;

        // Reset ready-screen
        this.$.readyScreen.hidden = false;
      }
      
      
      //
      // Listeners
      //

      /**
       * Called when the user has validated the ready screen.
       */
      start(e, detail) {
        console.log('[typio-practice-screen] starting', detail);
        this.initialized = true;
        
        this._content = detail.content;
        this.$.stats.init(detail.content, detail.classes);
        
        this.showChart = this.$.readyScreen.showChart;
        this.theme = detail.theme;
        this.mode = detail.mode;
        this.$.editor.theme = detail.theme;
        this.$.editor.mode = detail.mode;
        this.$.editor.content = this._content;
        this.$.editor.classes = detail.classes;
        this.$.editor.logicalLines = detail.logicalLines;
        this._intervals = this.$.stats.intervals;
        
        if (detail.fontSize) this.$.editor.fontSize = detail.fontSize;
        if (detail.preserveSpacing) this.$.editor.preserveSpacing = detail.preserveSpacing;
        
        console.log('[typio-practice-screen] launching editor...');
        this.$.editor.start();
        this.$.sleepTracker.start();
        this.$.chart.rows = this.$.stats.chartSteppedAreaRows();
        this.$.chart.redraw();
      }
      
      cancel() {
        if (this.started) {
          this.$.editor.cancel();
        }
      }
      
      pause() {
        this.paused = true;
        this.$.stats.pauseTimer();
      }
      
      resume() {
        this.paused = false;
        this.$.stats.resumeTimer();
      }
      
      rewind(numberCharacters = 10) {
        this.$.editor.backward(numberCharacters);
        this.$.stats.rewind(numberCharacters);
      }

      _characterEntered(e, detail) {
        // Update stats
        if (detail.indexValid <= 1) { // First character entered?
          this.$.stats.resumeTimer();
          this.started = true;
        }
        this.$.stats.newCharacter(detail.index, detail.character, detail.valid, detail.accepted);
        this.$.sleepTracker.newActivity();
        this.currentWpm = this.$.stats.currentWpm;
        
        // Update charts when necessary
        let refreshThreshold = Math.min(20, Math.floor(this.$.stats.totalCharacters / 20)); // At least twice per interval and every 10 characters
        if (this.$.stats.enteredCharacters - this._lastPositionWhenRefresh > refreshThreshold) {
          this.$.chart.style.display = 'block !important'; // bug otherwise
          this.$.chart.rows = this.$.stats.chartSteppedAreaRows();
          this.$.chart.redraw();
          this._lastPositionWhenRefresh = this.$.stats.enteredCharacters;
        }
      }

      _typingEnded() {
        // Show stats
        this.$.stats.stopTimer();
        this.$.sleepTracker.stop();
        this.statsSummary = this.$.stats.summary;
        this.mostDifficultKeys = this.$.stats.mostDifficultKeys(3);
        this.mostDifficultKeyCombinations = this.$.stats.mostDifficultKeyCombinations(3);
        this.mostDifficultWords = this.$.stats.mostDifficultWords(this._difficultWordOptions());
        
        // Show mini chart
        this._updateCharts();
        
        // Highlight errors
        this.$.editor.showMispellings();
        this.$.editor.moveToFirstPage();
        
        this.ended = true; // trigger changes on screen        
      }
      
      _difficultWordOptions() {
        const delimitersPerType = new Map();
        delimitersPerType.set('code', '\n');
        delimitersPerType.set('literature', '[\\s(),;.!?:"\']');
        
        let options = {
          n: 10
        }
        if (delimitersPerType.has(this.type)) {
          options.wordDelimiters = delimitersPerType.get(this.type);
        }
        return options;
      }
      
      _updateCharts() {
        this._updateMiniChart();
        this._updateSteppedAreaChart();
        this._updateHeatmapChart();
        this._updateScatterChart();
        this._updateLineChart();
      }

      _updateMiniChart() {
        this.$.miniChart.rows = this.$.stats.chartSteppedAreaRows();
        for (let i = 0; i < this.$.miniChart.rows.length; i++) {
          this.$.miniChart.rows[i][2] = ''; // remove annotations
        }
        this.$.miniChart.redraw();
        
        this.listenChartEvents();
      }
      
      _updateSteppedAreaChart() {
        this._setSteppedAreaData(this.$.stats.chartSteppedAreaData());
        this.$.steppedAreaChart.redraw();
      }
      
      _updateHeatmapChart() {
        this._setHeatmapData(this.$.stats.chartStackedBarData());
        this.$.heatmapChart.redraw();
      }
      
      _updateScatterChart() {
        this._setScatterData(this.$.stats.chartScatterData());
        this.$.scatterChart.redraw();
      }

      _updateLineChart() {
        this._setLineData(this.$.stats.chartLineData());
        this.$.lineChart.redraw();
      }

      /**
       * Let user click on the histogram to select a bar
       * and focus the corresponding text.
       */
      listenChartEvents() {
        if (!this._chartEventsListened) {
          google.visualization.events.addListener(this.$.miniChart._chart, 'select', () => {
            let selection = this.$.miniChart._chart.getSelection();
            if (!selection.length) {
              return;
            }

            let column = selection[0].row;
            
            // Highlight the characters belonging to the selected interval
            let startIndex = this._intervals.indexOf(column);
            let endIndex = this._intervals.lastIndexOf(column);
            this.$.editor.highlightBetween(startIndex, endIndex + 1, true);
            this.$.editor.position = startIndex;
          });
          this._chartEventsListened = true;
        }
      }
      
      _sleepDetected(event, detail) {
        this.pause();
      }
      
      _resumeClicked(event, detail) {
        this.resume();
      }
      

      // 
      // Heatmap
      // 
      
      showHeatmap() {
        const responseTimes = this.$.stats.getResponseTimeKeys();
        const responseTimePerKey = new Map();
        let worstInMs = 0;
        responseTimes.forEach(keyStats => { 
          responseTimePerKey.set(keyStats.character, keyStats);
          if (keyStats.averageInMs > worstInMs) {
            worstInMs = keyStats.averageInMs;
          }
        });

        this.$.keyboard.labelizeKeyboard();
        this.$.keyboard.colorize(c => {
          if (!responseTimePerKey.has(c)) return false;
          const stats = responseTimePerKey.get(c);
          
          // We compare the response time with the worst response time to determine the color
          // We only want to highlight the worse keys, even if the user is typing slowy every key.
          const ratio = Math.floor(stats.averageInMs * 100 / worstInMs / 10.1); // Note between 0 and 10 exclusive
          // close to 10 = reddish
          // close to 0 = yellowish
          
          const ignoreBelowRatio = 2;
          if (ratio < ignoreBelowRatio) return false; 
          
          // See https://material.io/guidelines/style/color.html#color-color-palette
          return 'var(--paper-red-' + ((ratio - ignoreBelowRatio) * 100) + ')';
        });
        
        
        const fingerRepartition = TypioKeyboard.fingersFromText(this._content);
        const maxFingerCount = Math.max(
          fingerRepartition.leftHand.littleFinger,
          fingerRepartition.leftHand.ringFinger,
          fingerRepartition.leftHand.middleFinger,
          fingerRepartition.leftHand.indexFinger,
          fingerRepartition.leftHand.thumb,
          fingerRepartition.rightHand.littleFinger,
          fingerRepartition.rightHand.ringFinger,
          fingerRepartition.rightHand.middleFinger,
          fingerRepartition.rightHand.indexFinger,
          fingerRepartition.rightHand.thumb,
        );
        this.$.hands.colorizeLeftHand({
          littleFinger: TypioPracticeScreen.dynamicRedColor(fingerRepartition.leftHand.littleFinger, maxFingerCount),
          ringFinger:   TypioPracticeScreen.dynamicRedColor(fingerRepartition.leftHand.ringFinger, maxFingerCount),
          middleFinger: TypioPracticeScreen.dynamicRedColor(fingerRepartition.leftHand.middleFinger, maxFingerCount),
          indexFinger:  TypioPracticeScreen.dynamicRedColor(fingerRepartition.leftHand.indexFinger, maxFingerCount),
          thumb:        TypioPracticeScreen.dynamicRedColor(fingerRepartition.leftHand.thumb, maxFingerCount),
        });
        this.$.hands.colorizeRightHand({
          littleFinger: TypioPracticeScreen.dynamicRedColor(fingerRepartition.rightHand.littleFinger, maxFingerCount),
          ringFinger:   TypioPracticeScreen.dynamicRedColor(fingerRepartition.rightHand.ringFinger, maxFingerCount),
          middleFinger: TypioPracticeScreen.dynamicRedColor(fingerRepartition.rightHand.middleFinger, maxFingerCount),
          indexFinger:  TypioPracticeScreen.dynamicRedColor(fingerRepartition.rightHand.indexFinger, maxFingerCount),
          thumb:        TypioPracticeScreen.dynamicRedColor(fingerRepartition.rightHand.thumb, maxFingerCount),
        });
        
        this.$.heatmap.style.display = 'block';
      }
      
      hideHeatmap() {
        this.$.heatmap.style.display = 'none';
      }   
      
      //
      // Shortcuts
      //
      
      startable() {
        if (this.paused) this.resume();
        if (this.started) return;
        this.$.readyScreen.start();
      }
      
      backable() {
        this.rewind();
      }
      
      
      //
      // Utils
      //
      
      static dynamicPaperColor(paperColor, actualValue, maxValue) {
        if (actualValue === 0) {
          return 'inherit'; // let blank if no value
        }
        
        let paperValue = Math.floor(actualValue * 100 / maxValue / 10) * 100;
        if (paperValue > 900) {
          paperValue = 900;
        }
        
        return `var(--paper-${paperColor}-${paperValue})`;
      }
      
      static dynamicRedColor(actualValue, maxValue) {
        return TypioPracticeScreen.dynamicPaperColor('red', actualValue, maxValue);
      }

    }
    window.customElements.define(TypioPracticeScreen.is, TypioPracticeScreen);


  </script>
</dom-module>
