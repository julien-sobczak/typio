<link rel="import" href="../../bower_components/polymer/polymer-element.html">

<link rel="import" href="/src/typio-app/shared-styles.html">

<dom-module id="typio-stats">
  <template>
    <style include="shared-styles">

      :host {
      }

      .wpm {
        font-weight: bold;
        font-size: 1.7em;
      }

      ul#stats, ul#keys, ul#keyCombinations {
        list-style-type: none;
      }
      ul#stats li {
        margin: 10px 15px;
      }
      ul#keys li {
        display: inline-block;
      }
      .key {
        display: inline-block;
        height: 35px;
        width: 35px;
        padding: 10px 10px;
        text-align: center;
        color: white;
        font-family: var(--logo-font-family);
        background-color: var(--typio-bg-color);
        margin: 10px 15px;
        border-radius: 3px;
        box-shadow: 2px 2px gray;
      }
      .elapsedTime {
        font-size: 12px;
        color: gray;
      }

      #table {
        margin-bottom: 25px;
      }

      #stats.headless-true {
        display: none;
      }
      #stats.ended-true #statsInProgress {
        display: none;
      }
      #stats.ended-false #statsFinished {
        display: none;
      }

    </style>

    <div id="stats" class$="ended-{{_ended}} headless-{{headless}}">
      <span id="statsInProgress" class="wpm">[[currentWpm]] WPM</span>
      
      <div id="statsFinished">
        <div>
          <span>WPM <strong>[[wpm]]</strong> in [[elapsedTimeInS]]s</span>
          <ul id="stats">
            <li>Total characters: [[totalCharacters]]</li>
            <li>Typeable characters: [[totalEditableCharacters]]</li>
            <li>Typed characters: [[enteredCharacters]]</li>
            <li>Unproductive keystroke overhead: [[unproductiveKeystrokeOverhead]]%</li>
          </ul>
        </div>
        <div>
          <span>Most difficult keys</span>
          <ul id="keys">
            <template is="dom-repeat" items="{{mostDifficultKeys}}">
            <li><span class="key">[[item.character]]</span><span class="elapsedTime">[[item.averageInMs]] ms</span></li>
            </template>
          </ul>
        </div>
        <div>
          <span>Most difficult key combinations</span>
          <ul id="keyCombinations">
            <template is="dom-repeat" items="{{mostDifficultKeyCombinations}}">
            <li><span class="key" inner-h-t-m-l="[[item.fromCharacter]]"></span> &rarr; <span class="key" inner-h-t-m-l="[[item.toCharacter]]"></span><span class="elapsedTime">[[item.averageInMs]] ms</span></li>
            </template>
          </ul>
        </div>
      </div>
      
    </div>

  </template>

  <script>

    /**
     * @customElement
     * @polymer
     */
    class TypioStats extends Polymer.Element {

      static get is() { return 'typio-stats'; }
      static get properties() {
        return {

          /**
           * Display nothing in headless mode. 
           * Metrics could be retrieved using the API instead.
           */
          headless: {
            type: Boolean,
            value: false
          },


          /**
           * True when the timer is over.
           */
          _ended: {
            type: Boolean,
            value: false
          },


          //
          // Stats
          //

          /**
           * The total number of characters (including ignorable characters)
           */
          totalCharacters: {
            type: Number,
            readOnly: true,
            value: 0
          },

          /**
           * The total number of enterable characters.
           * (Ignorable characters are not counted.)
           */
          totalEditableCharacters: {
            type: Number,
            readOnly: true,
            value: 0
          },

          /**
           * The number of entered characters since starting.
           */
          enteredCharacters: {
            type: Number,
            readOnly: true,
            value: 0
          },

          /**
           * The timestamp of the first entered characters.
           */
          _startTimestamp: {
            type: Date,
            value: null
          },

          /**
           * The timestamp of the last entered characters.
           */
          _endTimestamp: {
            type: Date,
            value: null
          },

          /**
           * The current WPM.
           *
           * This value is periodically refreshed and not systematically
           * after each input.
           */
          currentWpm: {
            type: Number,
            readOnly: true,
            value: 0
          },


          /**
           * A raw value to represent the editable characters among the total characters.
           *
           * See `_parseEditableCharacters` for supported formats.
           */
          editableCharacters: {
            type: Object,
            value: null,
            observer: '_editableCharactersChanged'
          },

          /**
           * A boolean character for each charcter (from 0 to `totalCharacters`)
           * that determines if the character should be entered.
           */
          _editables: {
            type: Array,
            value: []
          },

          /**
          * An index number for each character (from 0 to `intervalNumber` - 1)
          * that determines in which interval the character belongs.
          *
          * This could be used to show a progress chart.
          */
          intervals: {
            type: Array,
            //readOnly: true,
            value: []
          },

          /**
           * The list of entered characters (right or wrong).
           *
           * For each element, we keep the properties:
           * - `index`:     the current position
           * - `character`: the given character
           * - `valid`:     if the character was the one expected
           * - `accepted`:  if the character was accepted (when continue on errors)
           * - `timestamp`: when the character was pressed
           * - 'durationInMs': the elapsed time from the last valid input
           */
          _inputs: {
            type: Array,
            value: []
          },


          //
          // Summary statistics
          //

          /**
           *
           */
          unproductiveKeystrokeOverhead: {
            type: Number,
            //readOnly: true,
            value: 0
          },

          /**
           *
           */
          elapsedTimeInS: {
            type: Number,
            //readOnly: true,
            value: 0
          },

          /**
           *
           */
          wpm: {
            type: Number,
            //readOnly: true,
            value: 0
          },

          /**
           *
           */
          mostDifficultKeys: {
            type: Array,
            value: []
          },

          /**
           *
           */
          mostDifficultKeyCombinations: {
            type: Array,
            value: []
          },


          //
          // Constants
          //

          /**
           * The number of intervals to use to split the text.
           */
          intervalNumber: {
            type: Number,
            value: 10
          },

          /**
           * Minimum number of characters in an interval before evaluating the WPM.
           */
          minCharactersPerInterval: {
            type: Number,
            value: 3
          }

        };
      }

      //
      // Configuration
      //

      ready() {
        super.ready();
        this.WPM_GREAT = 60;
        this.WPM_WOW = 80;
        this.WPM_FANTASTIC = 100;

        this.reset();
      }

      _editableCharactersChanged() {
        this._editables = this._parseEditableCharacters(this.editableCharacters);
        this._setTotalCharacters(this._editables.length);
        this._setTotalEditableCharacters(this._countEditableCharacters());
        this._determineIntervals();
      }

      reset() {
        this._setTotalCharacters(0);
        this._setTotalEditableCharacters(0);
        this._setEnteredCharacters(0);
        this._setCurrentWpm(0);
        this._startTimestamp = null;
        this._endTimestamp = null;
        this._ended = false;

        this._editables = [];
        this._inputs = [];
        this.intervals = [];
      }

      /**
       * The most basic accepted format is an array of boolean value (false means ignorable characters).
       *
       * A string format is supported ('X' represents false and '-' represent true).
       * This syntax is particulary adapted for unit test to avoid large illisible arrays.
       */
      _parseEditableCharacters(editables) {
        if (Array.isArray(editables)) {
          return editables;
        }

        if (typeof(editables) === 'string') {
          let result = [];
          for (let i = 0; i < editables.length; i++) {
            result.push(editables.charAt(i) === 'X' ? false : true);
          }
          return result;
        }

        return [];
      }


      //
      // Timer
      //

      startTimer(timestamp = new Date()) {
        this._startTimestamp = timestamp;
      }

      stopTimer(timestamp = new Date()) {
        this._endTimestamp = timestamp;
        this._ended = true;
        this._calculateSummaryStatistics();
      }

      resumeTimer() {
        if (!this._startTimestamp) {
          this.startTimer();
        }
      }


      //
      // Input
      // (Accept input from the user)

      newCharacter(index, character, valid, accepted, timestamp = new Date()) {
        if (character === 'Enter') character = '\\n';
        let durationInMs = timestamp - this._startTimestamp;
        for (let i = this._inputs.length - 1; i >= 0; i--) {
          if (this._inputs[i].accepted === true) {
            durationInMs = timestamp - this._inputs[i].timestamp;
            break;
          }
        }
        this._inputs.push({
          'index': index,
          'character': character,
          'valid': valid,
          'accepted': accepted,
          'timestamp': timestamp,
          'durationInMs':  durationInMs,
        });
        this._setEnteredCharacters(this.enteredCharacters + 1);
        this._setCurrentWpm(this._calculateCurrentWpm());
      }


      //
      // Intervals
      //

      _determineIntervals() {
        this.intervals = [];

        // Assign an interval number to each character
        // Dispatch uniformly editable characters among intervals.
        const charactersPerInterval = Math.floor(this.totalEditableCharacters / this.intervalNumber);
        // = change interval when `charactersPerInterval` has been entered in the current interval

        let currentInterval = 0;
        let countEditableCharactersInCurrentInterval = 0;
        for (let editable of this._editables) {
          this.intervals.push(currentInterval);

          if (editable) countEditableCharactersInCurrentInterval++;
          if (countEditableCharactersInCurrentInterval == charactersPerInterval &&
            currentInterval + 1 < this.intervalNumber) {
            // move to next interval
            currentInterval++;
            countEditableCharactersInCurrentInterval = 0;
          }
        }
      }

      _countEditableCharacters() {
        let countEditables = 0;
        for (let i = 0; i < this._editables.length; i++) {
          if (this._editables[i]) {
            countEditables++;
          }
        }
        return countEditables;
      }


      //
      // WPM
      //

      /**
       * Return WPM per interval.
       *
       * The output format is compatible with the Google chart expected format. (see typio-editor).
       */
      wpmPerInterval() {
        // Init the result to blank
        let result = [];
        for (let i = 0; i < this.intervalNumber; i++) {
          result.push(["", undefined, "", ""]);
        }

        // Search the current interval
        // TODO refactor to keep this information while progressing
        let currentInterval = 0;
        for (let i = this._inputs.length - 1; i >= 0; i--) { // Optmization: search backward
          let input = this._inputs[i];
          if (input.accepted) {
            currentInterval = this.intervals[input.index];
            break;
          }
        }

        for (let i = 0; i <= currentInterval; i++) {
          // we determine WPM for this range
          let firstTimestamp = undefined;
          let lastTimestamp = undefined;
          let characterCount = 0;
          for (let j = 0; j < this._inputs.length; j++) {
            let input = this._inputs[j];
            if (this.intervals[input.index] != i) continue; // not the same interval
            if (input.accepted) {
              characterCount++;
            }
            if (!firstTimestamp) {
              firstTimestamp = input.timestamp;
            } else {
              lastTimestamp = input.timestamp;
            }
          }

          if (characterCount >= this.minCharactersPerInterval) {
            // We wait at least 3 characters before displaying the WPM
            // to avoid diplaying peaks at the start of each interval
            let wpm = Math.round(characterCount / TypioStats.durationInS(firstTimestamp, lastTimestamp) * 60.0 / 5);
            result[i][0] = isFinite(wpm) ? '' + wpm : '-';
            result[i][1] = wpm;
            result[i][2] = (wpm > this.WPM_FANTASTIC) ? 'fantastic!' : (wpm > this.WPM_WOW) ? 'wow' : (wpm > this.WPM_GREAT) ? 'great' : '';
          }
        }

        if (!this._ended) {
          result[currentInterval][3] = "color: Gold";
        }

        return result;
      }

      // Current WPM value. Unlike wpm(), this method could be call anytime.
      _calculateCurrentWpm() {
        if (this.enteredCharacters < 10) {
          return 0;
        }
        return Math.round(this.enteredCharacters / this._calculateElapsedTimeInS() * 60.0 / 5);
      }


      //
      // Summary statistics
      //

      _calculateSummaryStatistics() {
        this.unproductiveKeystrokeOverhead = this._calculateUnproductiveKeystrokeOverhead();
        this.elapsedTimeInS = this._calculateElapsedTimeInS();
        this.wpm = this._calculateWpm();
        this.mostDifficultKeys = this._mostDifficultKeys(3);
        this.mostDifficultKeyCombinations = this._mostDifficultKeyCombinations(3);
      }

      _calculateUnproductiveKeystrokeOverhead() {
        return Math.round(this.enteredCharacters * 100 / this.totalEditableCharacters - 100, "%");
      }

      _calculateElapsedTimeInS() {
        let end = this._endTimestamp;
        if (!end) {
          end = new Date();
        }
        return TypioStats.durationInS(this._startTimestamp, end);
      }

      _calculateWpm() {
        // see https://en.wikipedia.org/wiki/Words_per_minute for official definition
        return Math.round(this.totalEditableCharacters / this.elapsedTimeInS * 60.0 / 5);
      }

      //
      // Difficulties
      //

      /**
       * Returns an ordered array (most difficult to easier) of characters.
       *
       * The number of characters to return is determined by the parameter.
       *
       * Each returned entry is an object respecting the format:
       * {
       *   character: 'A',
       *   averageInMs: 1.5, // ms
       *   minInMs: 1,       // ms
       *   maxInMs: 3,       // ms
       *   occurrences: 5
       * }
       */
      _mostDifficultKeys(n = 10) {
        let result = new Map();

        for (let input of this._inputs) {
          if (!input.valid) continue; // We are only interested in valid character
          if (!result.has(input.character)) {
            result.set(input.character, {
              character: this._formatCharacter(input.character),
              totalInMs: 0,
              averageInMs: 0,
              minInMs: Number.MAX_VALUE,
              maxInMs: 0,
              occurrences: 0,
            });
          }
          let stats = result.get(input.character);
          stats.occurrences++;
          if (input.durationInMs < stats.minInMs) {
            stats.minInMs = input.durationInMs;
          }
          if (input.durationInMs > stats.maxInMs) {
            stats.maxInMs = input.durationInMs;
          }
          stats.totalInMs += input.durationInMs;
          stats.averageInMs = parseInt(stats.totalInMs / stats.occurrences);
        }

        // Sort in reverse order by average time and return only the first N results.
        let subresult = new Array(...result.values()).sort((a, b) => b.averageInMs - a.averageInMs);
        if (n > 0) {
          return subresult.slice(0, n);
        } else {
          return subresult;
        }
      }
      
      getResponseTimeKeys() {
        return this._mostDifficultKeys(0);
      }

      /**
       * Returns an ordered array (most difficult to easier) of combinations (2 successive characters).
       *
       * The number of combinations to return is determined by the parameter.
       *
       * Each returned entry is an object respecting the format:
       * {
       *   fromCharacter: '[',
       *   toCharacter: '{',
       *   averageInMs: 1.5, // ms
       *   minInMs: 1,       // ms
       *   maxInMs: 3,       // ms
       *   occurrences: 5
       * }
       */
      _mostDifficultKeyCombinations(n = 10) {
        let result = new Map();
        let prevCharacter = null;

        for (let input of this._inputs) {
          if (!input.valid) continue; // We are only interested in valid character

          if (prevCharacter) {
            const key = prevCharacter + '->' + input.character;
            if (!result.has(key)) {
              result.set(key, {
                fromCharacter: this._formatCharacter(prevCharacter),
                toCharacter: this._formatCharacter(input.character),
                totalInMs: 0,
                averageInMs: 0,
                minInMs: Number.MAX_VALUE,
                maxInMs: 0,
                occurrences: 0,
              });
            }
            let stats = result.get(key);
            stats.occurrences++;
            if (input.durationInMs < stats.minInMs) {
              stats.minInMs = input.durationInMs;
            }
            if (input.durationInMs > stats.maxInMs) {
              stats.maxInMs = input.durationInMs;
            }
            stats.totalInMs += input.durationInMs;
            stats.averageInMs = parseInt(stats.totalInMs / stats.occurrences);
          }

          prevCharacter = input.character;
        }

        // Sort in reverse order by average time and return only the first N results.
        return new Array(...result.values()).sort((a, b) => b.averageInMs - a.averageInMs).slice(0, n);
      }

      _formatCharacter(c) {
        if (c === ' ') return '&empty;';
        if (c === '\n') return '&#9166;';
        return c;
      }


      //
      // Utils
      //

      static durationInS(start, end) {
        return Math.round((end - start) / 1000);
      }

    }
    window.customElements.define(TypioStats.is, TypioStats);

  </script>
</dom-module>
