<link rel="import" href="../../bower_components/polymer/polymer-element.html">

<dom-module id="typio-stats">
  <script>

    /**
     * @customElement
     * @polymer
     */
    class TypioStats extends Polymer.Element {

      static get is() { return 'typio-stats'; }
      static get properties() {
        return {

          /**
           * True when the timer is over.
           */
          _ended: {
            type: Boolean,
            value: false
          },


          //
          // Stats
          //

          /**
           * The total number of characters (including ignorable characters)
           */
          totalCharacters: {
            type: Number,
            readOnly: true,
            value: 0
          },

          /**
           * The total number of enterable characters.
           * (Ignorable characters are not counted.)
           */
          totalEditableCharacters: {
            type: Number,
            readOnly: true,
            value: 0
          },

          /**
           * The number of entered characters since starting.
           */
          enteredCharacters: {
            type: Number,
            readOnly: true,
            value: 0
          },

          /**
           * The timestamp of the first entered characters.
           */
          _startTimestamp: {
            type: Date,
            value: null
          },

          /**
           * The timestamp of the last entered characters.
           */
          _endTimestamp: {
            type: Date,
            value: null
          },

          /**
           * The current WPM.
           *
           * This value is periodically refreshed and not systematically
           * after each input.
           */
          currentWpm: {
            type: Number,
            readOnly: true,
            value: 0
          },

          /**
           * A boolean character for each charcter (from 0 to `totalCharacters`)
           * that determines if the character should be entered.
           */
          _editables: {
            type: Array,
            value: []
          },

          /**
          * An index number for each character (from 0 to `numberOfIntervals` - 1)
          * that determines in which interval the character belongs.
          *
          * This could be used to show a progress chart.
          */
          intervals: {
            type: Array,
            //readOnly: true,
            value: []
          },

          /**
           * The list of entered characters (right or wrong).
           *
           * For each element, we keep the properties:
           * - `index`:     the current position
           * - `character`: the given character
           * - `valid`:     if the character was the one expected
           * - `accepted`:  if the character was accepted (when continue on errors)
           * - `timestamp`: when the character was pressed
           * - 'durationInMs': the elapsed time from the last valid input
           */
          _inputs: {
            type: Array,
            value: []
          },


          //
          // Summary statistics
          //
          
          summary: {
            type: Object,
            readOnly: true,
            value: null
          },


          //
          // Constants
          //

          /**
           * The number of intervals to use to split the text.
           */
          numberOfIntervals: {
            type: Number,
            value: 10
          },

          /**
           * Minimum number of characters in an interval before evaluating the WPM.
           */
          minCharactersPerInterval: {
            type: Number,
            value: 3
          }

        };
      }

      //
      // Configuration
      //

      ready() {
        super.ready();
        this.WPM_GREAT = 60;
        this.WPM_WOW = 80;
        this.WPM_FANTASTIC = 100;

        this.reset();
      }
      
      reset() {
        this._setTotalCharacters(0);
        this._setTotalEditableCharacters(0);
        this._setEnteredCharacters(0);
        this._setCurrentWpm(0);
        this._startTimestamp = null;
        this._endTimestamp = null;
        this._ended = false;

        this._editables = [];
        this._inputs = [];
        this.intervals = [];
      }
      
      init(content, classes = undefined) {
        this.content = content;
        this.classes = classes;
        
        // Be sure `classes` is valid 
        if (!classes) {
          this.classes = new Array();
          for (let i = 0; i < this.content.length; i++) {
            this.classes.push([]);
          }
        }

        this._editables = this._calculateEditableCharacters();
        this._setTotalCharacters(this._editables.length);
        this._setTotalEditableCharacters(this._countEditableCharacters());
        this._determineIntervals();
      }

      /**
       * Build an array having the same length as `content`. The ith element is
       * true if the character is editable (non-ignorable) by the user.
       */
      _calculateEditableCharacters() {
        let editables = new Array(this.content.length);
        for (let i = 0; i < this.content.length; i++) {
          editables[i] = !this.classes[i].includes('ignorable');
        }
        return editables;
      }


      //
      // Timer
      //

      startTimer(timestamp = new Date()) {
        this._startTimestamp = timestamp;
      }

      stopTimer(timestamp = new Date()) {
        this._endTimestamp = timestamp;
        this._ended = true;        
        this.calculateSummaryStatistics();
      }

      resumeTimer() {
        if (!this._startTimestamp) {
          this.startTimer();
        }
      }


      //
      // Input
      // (Accept input from the user)
      //

      newCharacter(index, character, valid, accepted, timestamp = new Date()) {
        // startTimer() is optional. If not called, we trigger the watch on first character.
        if (!this._startTimestamp) this._startTimestamp = timestamp;
        // stopTimer() is optional. If called, it will overriden this value. Otherwise, 
        // we consider the last entered input timestamp.
        this._endTimestamp = timestamp;
        
        if (character === 'Enter') character = '\\n';
        let durationInMs = timestamp - this._startTimestamp;
        for (let i = this._inputs.length - 1; i >= 0; i--) {
          if (this._inputs[i].accepted === true) {
            durationInMs = timestamp - this._inputs[i].timestamp;
            break;
          }
        }
        this._inputs.push({
          'index': index,
          'character': character,
          'valid': valid,
          'accepted': accepted,
          'timestamp': timestamp,
          'durationInMs':  durationInMs,
        });
        this._setEnteredCharacters(this.enteredCharacters + 1);
        this._setCurrentWpm(this._calculateCurrentWpm());
      }


      //
      // Intervals
      //

      _determineIntervals() {
        this.intervals = [];

        // Assign an interval number to each character
        // Dispatch uniformly editable characters among intervals.
        const charactersPerInterval = Math.max(Math.floor(this.totalEditableCharacters / this.numberOfIntervals), 1);
        // = change interval when `charactersPerInterval` has been entered in the current interval
        
        let currentInterval = 0;
        let countEditableCharactersInCurrentInterval = 0;
        for (let editable of this._editables) {
          this.intervals.push(currentInterval);

          if (editable) countEditableCharactersInCurrentInterval++;
          if (countEditableCharactersInCurrentInterval == charactersPerInterval &&
            currentInterval + 1 < this.numberOfIntervals) {
            // move to next interval
            currentInterval++;
            countEditableCharactersInCurrentInterval = 0;
          }
        }
      }

      _countEditableCharacters() {
        let countEditables = 0;
        for (let i = 0; i < this._editables.length; i++) {
          if (this._editables[i]) {
            countEditables++;
          }
        }
        return countEditables;
      }


      //
      // WPM
      //

      /**
       * Return WPM per interval.
       *
       * The output format is compatible with the Google chart expected format. (see typio-editor).
       */
      wpmPerInterval() {
        // Init the result to blank
        let result = [];
        for (let i = 0; i < this.numberOfIntervals; i++) {
          result.push(["", undefined, "", ""]);
        }

        // Search the current interval
        // TODO refactor to keep this information while progressing
        let currentInterval = 0;
        for (let i = this._inputs.length - 1; i >= 0; i--) { // Optmization: search backward
          let input = this._inputs[i];
          if (input.accepted) {
            currentInterval = this.intervals[input.index];
            break;
          }
        }

        for (let i = 0; i <= currentInterval; i++) {
          // we determine WPM for this range
          let firstTimestamp = undefined;
          let lastTimestamp = undefined;
          let characterCount = 0;
          for (let j = 0; j < this._inputs.length; j++) {
            let input = this._inputs[j];
            if (this.intervals[input.index] != i) continue; // not the same interval
            if (input.accepted) {
              characterCount++;
            }
            if (!firstTimestamp) {
              firstTimestamp = input.timestamp;
            } else {
              lastTimestamp = input.timestamp;
            }
          }

          if (characterCount >= this.minCharactersPerInterval) {
            // We wait at least 3 characters before displaying the WPM
            // to avoid diplaying peaks at the start of each interval
            let wpm = Math.round(characterCount / TypioStats.durationInS(firstTimestamp, lastTimestamp) * 60.0 / 5);
            result[i][0] = isFinite(wpm) ? '' + wpm : '-';
            result[i][1] = wpm;
            result[i][2] = (wpm > this.WPM_FANTASTIC) ? 'fantastic!' : (wpm > this.WPM_WOW) ? 'wow' : (wpm > this.WPM_GREAT) ? 'great' : '';
          }
        }

        if (!this._ended) {
          result[currentInterval][3] = "color: Gold";
        }

        return result;
      }

      // Current WPM value. Unlike wpm(), this method could be call anytime.
      _calculateCurrentWpm() {
        if (this.enteredCharacters < 10) {
          return 0;
        }
        return Math.round(this.enteredCharacters / this._calculateElapsedTimeInS() * 60.0 / 5);
      }


      //
      // Summary statistics
      //

      calculateSummaryStatistics() {
        this._setSummary({
          // Export in progress stats
          'totalCharacters': this.totalCharacters,
          'totalEditableCharacters': this.totalEditableCharacters, 
          'enteredCharacters': this.enteredCharacters,
          
          // and calculate global stats
          'wpm': this._calculateEffectiveWpm(),
          'theoricalWpm': this._calculateTheoricalWpm(),
          'unproductiveKeystrokeOverhead': this._calculateUnproductiveKeystrokeOverhead(),
          'elapsedTimeInS': this._calculateElapsedTimeInS(),
          'elapsedTimeInMs': this._calculateElapsedTimeInMs(),
        });
      }
      
      _calculateEffectiveWpm() {
        // see https://en.wikipedia.org/wiki/Words_per_minute for official definition
        const wpm = Math.round(this.totalEditableCharacters / this._calculateElapsedTimeInS() * 60.0 / 5);
        if (isFinite(wpm)) {
          return wpm;
        } else {
          return 0;
        }
      }
      
      _calculateTheoricalWpm() {
        // TODO
        return this._calculateEffectiveWpm();
      }

      _calculateUnproductiveKeystrokeOverhead() {
        return Math.max(0, Math.round(this.enteredCharacters * 100 / this.totalEditableCharacters - 100, "%"));
      }

      _calculateElapsedTimeInS() {
        let end = this._endTimestamp;
        if (!end) {
          end = new Date();
        }
        return TypioStats.durationInS(this._startTimestamp, end);
      }
      
      _calculateElapsedTimeInMs() {
        let end = this._endTimestamp;
        if (!end) {
          end = new Date();
        }
        return TypioStats.durationInMs(this._startTimestamp, end);
      }
  

      //
      // Difficulties
      //

      /**
       * Returns an ordered array (most difficult to easier) of characters.
       *
       * The number of characters to return is determined by the parameter.
       *
       * Each returned entry is an object respecting the format:
       * {
       *   character: 'A',
       *   averageInMs: 1.5, // ms
       *   minInMs: 1,       // ms
       *   maxInMs: 3,       // ms
       *   occurrences: 5
       * }
       */
      mostDifficultKeys(n = 10) {
        let result = new Map();

        for (let input of this._inputs) {
          if (!input.valid) continue; // We are only interested in valid character
          if (!result.has(input.character)) {
            result.set(input.character, {
              character: TypioStats._formatCharacter(input.character),
              totalInMs: 0,
              averageInMs: 0,
              minInMs: Number.MAX_VALUE,
              maxInMs: 0,
              occurrences: 0,
            });
          }
          let stats = result.get(input.character);
          stats.occurrences++;
          if (input.durationInMs < stats.minInMs) {
            stats.minInMs = input.durationInMs;
          }
          if (input.durationInMs > stats.maxInMs) {
            stats.maxInMs = input.durationInMs;
          }
          stats.totalInMs += input.durationInMs;
          stats.averageInMs = parseInt(stats.totalInMs / stats.occurrences);
        }

        // Sort in reverse order by average time and return only the first N results.
        let subresult = new Array(...result.values()).sort((a, b) => b.averageInMs - a.averageInMs);
        if (n > 0) {
          return subresult.slice(0, n);
        } else {
          return subresult;
        }
      }
      
      getResponseTimeKeys() {
        return this.mostDifficultKeys(0);
      }

      /**
       * Returns an ordered array (most difficult to easier) of combinations (2 successive characters).
       *
       * The number of combinations to return is determined by the parameter.
       *
       * Each returned entry is an object respecting the format:
       * {
       *   fromCharacter: '[',
       *   toCharacter: '{',
       *   averageInMs: 1.5, // ms
       *   minInMs: 1,       // ms
       *   maxInMs: 3,       // ms
       *   occurrences: 5
       * }
       */
      mostDifficultKeyCombinations(n = 10) {
        let result = new Map();
        let prevCharacter = null;

        for (let input of this._inputs) {
          if (!input.valid) continue; // We are only interested in valid character

          if (prevCharacter) {
            const key = prevCharacter + '->' + input.character;
            if (!result.has(key)) {
              result.set(key, {
                fromCharacter: TypioStats._formatCharacter(prevCharacter),
                toCharacter: TypioStats._formatCharacter(input.character),
                totalInMs: 0,
                averageInMs: 0,
                minInMs: Number.MAX_VALUE,
                maxInMs: 0,
                occurrences: 0,
              });
            }
            let stats = result.get(key);
            stats.occurrences++;
            if (input.durationInMs < stats.minInMs) {
              stats.minInMs = input.durationInMs;
            }
            if (input.durationInMs > stats.maxInMs) {
              stats.maxInMs = input.durationInMs;
            }
            stats.totalInMs += input.durationInMs;
            stats.averageInMs = parseInt(stats.totalInMs / stats.occurrences);
          }

          prevCharacter = input.character;
        }

        // Sort in reverse order by average time and return only the first N results.
        return new Array(...result.values()).sort((a, b) => b.averageInMs - a.averageInMs).slice(0, n);
      }


      //
      // Utils
      //
      
      static _formatCharacter(c) {
        if (c === ' ') return '&empty;';
        if (c === '\n') return '&#9166;';
        return c;
      }

      static durationInS(start, end) {
        return Math.round((end - start) / 1000);
      }
      
      static durationInMs(start, end) {
        return end - start;
      }

    }
    window.customElements.define(TypioStats.is, TypioStats);

  </script>
</dom-module>
