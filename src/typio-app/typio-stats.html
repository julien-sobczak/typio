<link rel="import" href="../../bower_components/polymer/polymer-element.html">

<link rel="import" href="/src/typio-app/shared-styles.html">

<dom-module id="typio-stats">
  <template>
    <style include="shared-styles">

      :host {
      }

      .wpm {
        font-weight: bold;
        font-size: 2em;
      }

    </style>

    <template is="dom-if" if="[[!_ended]]">
      <span class="wpm">[[currentWpm]] WPM</span>
    </template>
    <template id="table" is="dom-if" if="[[_ended]]">
      <table>
        <tbody>
          <tr class="totalCharacters"><th>Total characters</th><td>[[totalCharacters]]</td></tr>
          <tr class="totalEditableCharacters"><th>Typeable characters</th><td>[[totalEditableCharacters]]</td></tr>
          <tr class="enteredCharacters"><th>Typed characters</th><td>[[enteredCharacters]]</td></tr>
          <tr class="unproductiveKeystrokeOverhead"><th>Unproductive keystroke overhead</th><td>[[unproductiveKeystrokeOverhead]]%</td></tr>
          <tr class="elapsedTimeInS"><th>Elasped time</th><td>[[elapsedTimeInS]]s</td></tr>
          <tr class="wpm"><th>WPM</th><td>[[wpm]]</td></tr>
        </tbody>
      </table>
    </template>

  </template>

  <script>

    /**
     * @customElement
     * @polymer
     */
    class TypioStats extends Polymer.Element {

      static get is() { return 'typio-stats'; }
      static get properties() {
        return {

          /**
           * The type of content (code, literature).
           */
          type: {
            type: String,
            value: "code"
          },

          /**
           * Language of the content.
           *
           * Could be a programming language (Java, Python) or a
           * spoken language (French, English).
           *
           * Note: Case is not important.
           */
          language: {
            type: String,
            value: "Python"
          },

          /**
           * The content to touch type.
           *
           * This property should be set in JavaScript and
           * not through an HTML attribute to avoid HTML escaping (&lt; for <).
           */
          content: {
            type: String,
            value: 'print("Hello World")\n'
          },


          /**
           * True when the timer is over.
           */
          _ended: {
            type: Boolean,
            value: false
          },


          //
          // Stats
          //

          /**
           * The total number of characters (including ignorable characters)
           */
          totalCharacters: {
            type: Number,
            readOnly: true,
            value: 0
          },

          /**
           * The total number of enterable characters.
           * (Ignorable characters are not counted.)
           */
          totalEditableCharacters: {
            type: Number,
            readOnly: true,
            value: 0
          },

          /**
           * The number of entered characters since starting.
           */
          enteredCharacters: {
            type: Number,
            readOnly: true,
            value: 0
          },

          /**
           * The timestamp of the first entered characters.
           */
          _startTimestamp: {
            type: Date,
            value: null
          },

          /**
           * The timestamp of the last entered characters.
           */
          _endTimestamp: {
            type: Date,
            value: null
          },

          /**
           * The current WPM.
           *
           * This value is periodically refreshed and not systematically
           * after each input.
           */
          currentWpm: {
            type: Number,
            readOnly: true,
            value: 0
          },


          /**
           * A raw value to represent the editable characters among the total characters.
           *
           * See `_parseEditableCharacters` for supported formats.
           */
          editableCharacters: {
            type: Object,
            value: null,
            observer: '_editableCharactersChanged'
          },

          /**
           * A boolean character for each charcter (from 0 to `totalCharacters`)
           * that determines if the character should be entered.
           */
          _editables: {
            type: Array,
            value: []
          },

          /**
          * An index number for each character (from 0 to `intervalNumber` - 1)
          * that determines in which interval the character belongs.
          *
          * This could be used to show a progress chart.
          */
          intervals: {
            type: Array,
            //readOnly: true,
            value: []
          },

          /**
           * The list of entered characters (right or wrong).
           *
           * For each element, we keep the properties:
           * - `index`:     the current position
           * - `character`: the given character
           * - `valid`:     if the character was the one expected
           * - `accepted`:  if the character was accepted (when continue on errors)
           * - `timestamp`: when the character was pressed
           */
          _inputs: {
            type: Array,
            value: []
          },


          //
          // Summary statistics
          //

          /**
           *
           */
          unproductiveKeystrokeOverhead: {
            type: Number,
            //readOnly: true,
            value: 0
          },

          /**
           *
           */
          elapsedTimeInS: {
            type: Number,
            //readOnly: true,
            value: 0
          },

          /**
           *
           */
          wpm: {
            type: Number,
            //readOnly: true,
            value: 0
          },


          //
          // Constants
          //

          /**
           * The number of intervals to use to split the text.
           */
          intervalNumber: {
            type: Number,
            value: 10
          },

          /**
           * Minimum number of characters in an interval before evaluating the WPM.
           */
          minCharactersPerInterval: {
            type: Number,
            value: 3
          }

        };
      }

      //
      // Configuration
      //

      ready() {
        super.ready();
        this.WPM_GREAT = 60;
        this.WPM_WOW = 80;
        this.WPM_FANTASTIC = 100;

        this.reset();
      }

      _editableCharactersChanged() {
        this._editables = this._parseEditableCharacters(this.editableCharacters);
        this._setTotalCharacters(this._editables.length);
        this._setTotalEditableCharacters(this._countEditableCharacters());
        this._determineIntervals();
      }

      reset() {
        this._setTotalCharacters(0);
        this._setTotalEditableCharacters(0);
        this._setEnteredCharacters(0);
        this._setCurrentWpm(0);
        this._startTimestamp = null;
        this._endTimestamp = null;
        this._ended = false;

        this._editables = [];
        this._inputs = [];
        this.intervals = [];
      }

      /**
       * The most basic accepted format is an array of boolean value (false means ignorable characters).
       *
       * A string format is supported ('X' represents false and '-' represent true).
       * This syntax is particulary adapted for unit test to avoid large illisible arrays.
       */
      _parseEditableCharacters(editables) {
        if (Array.isArray(editables)) return editables;

        if (typeof(editables) === 'string') {
          let result = [];
          for (let i = 0; i < editables.length; i++) {
            result.push(editables.charAt(i) === 'X' ? false : true);
          }
          return result;
        }

        return [];
      }


      //
      // Timer
      //

      startTimer(timestamp = new Date()) {
        this._startTimestamp = timestamp;
      }

      stopTimer(timestamp = new Date()) {
        this._endTimestamp = timestamp;
        this._ended = true;
        this._calculateSummaryStatistics();
      }

      resumeTimer() {
        if (!this._startTimestamp) {
          this.startTimer();
        }
      }


      //
      // Input
      // (Accept input from the user)

      newCharacter(index, character, valid, accepted, timestamp = new Date()) {
        this._inputs.push({
          'index': index,
          'character': character,
          'valid': valid,
          'accepted': accepted,
          'timestamp': timestamp
        });
        this._setEnteredCharacters(this.enteredCharacters + 1);
        this._setCurrentWpm(this._calculateCurrentWpm());
      }


      //
      // Intervals
      //

      _determineIntervals() {
        this.intervals = [];

        // Assign an interval number to each character
        // Dispatch uniformly editable characters among intervals.
        const charactersPerInterval = Math.ceil(this.totalEditableCharacters / this.intervalNumber);
        // = change interval when `charactersPerInterval` has been entered in the current interval

        let currentInterval = 0;
        let countEditableCharactersInCurrentInterval = 0;
        for (let editable of this._editables) {
          this.intervals.push(currentInterval);

          if (editable) countEditableCharactersInCurrentInterval++;
          if (countEditableCharactersInCurrentInterval == charactersPerInterval) {
            // move to next interval
            currentInterval++;
            countEditableCharactersInCurrentInterval = 0;
          }
        }
      }

      _countEditableCharacters() {
        let countEditables = 0;
        for (let i = 0; i < this._editables.length; i++) {
          if (this._editables[i]) {
            countEditables++;
          }
        }
        return countEditables;
      }


      //
      // WPM
      //

      /**
       * Return WPM per interval.
       *
       * The output format is compatible with the Google chart expected format. (see typio-editor).
       */
      wpmPerInterval() {
        // Init the result to blank
        let result = [];
        for (let i = 0; i < this.intervalNumber; i++) {
          result.push(["", undefined, "", ""]);
        }

        // Search the current interval
        // TODO refactor to keep this information while progressing
        let currentInterval = 0;
        for (let i = this._inputs.length - 1; i >= 0; i--) { // Optmization: search backward
          let input = this._inputs[i];
          if (input.accepted) {
            currentInterval = this.intervals[input.index];
            break;
          }
        }

        for (let i = 0; i <= currentInterval; i++) {
          // we determine WPM for this range
          let firstTimestamp = undefined;
          let lastTimestamp = undefined;
          let characterCount = 0;
          for (let j = 0; j < this._inputs.length; j++) {
            let input = this._inputs[j];
            if (this.intervals[input.index] != i) continue; // not the same interval
            if (input.accepted) {
              characterCount++;
            }
            if (!firstTimestamp) {
              firstTimestamp = input.timestamp;
            } else {
              lastTimestamp = input.timestamp;
            }
          }

          if (characterCount >= this.minCharactersPerInterval) {
            // We wait at least 3 characters before displaying the WPM
            // to avoid diplaying peaks at the start of each interval
            let wpm = Math.round(characterCount / TypioStats.durationInS(firstTimestamp, lastTimestamp) * 60.0 / 5);
            result[i][0] = isFinite(wpm) ? '' + wpm : '-';
            result[i][1] = wpm;
            result[i][2] = (wpm > this.WPM_FANTASTIC) ? 'fantastic!' : (wpm > this.WPM_WOW) ? 'wow' : (wpm > this.WPM_GREAT) ? 'great' : '';
          }
        }

        if (!this._ended) {
          result[currentInterval][3] = "color: Gold";
        }

        return result;
      }

      // Current WPM value. Unlike wpm(), this method could be call anytime.
      _calculateCurrentWpm() {
        if (this.enteredCharacters < 10) {
          return 0;
        }
        return Math.round(this.enteredCharacters / this._calculateElapsedTimeInS() * 60.0 / 5);
      }


      //
      // Summary statistics
      //

      _calculateSummaryStatistics() {
        this.unproductiveKeystrokeOverhead = this._calculateUnproductiveKeystrokeOverhead();
        this.elapsedTimeInS = this._calculateElapsedTimeInS();
        this.wpm = this._calculateWpm();
      }

      _calculateUnproductiveKeystrokeOverhead() {
        return Math.round(this.enteredCharacters * 100 / this.totalEditableCharacters - 100, "%");
      }

      _calculateElapsedTimeInS() {
        let end = this._endTimestamp;
        if (!end) {
          end = new Date();
        }
        return TypioStats.durationInS(this._startTimestamp, end);
      }

      _calculateWpm() {
        // see https://en.wikipedia.org/wiki/Words_per_minute for official definition
        return Math.round(this.totalEditableCharacters / this.elapsedTimeInS * 60.0 / 5);
      }

      //
      // Utils
      //

      static durationInS(start, end) {
        return Math.round((end - start) / 1000);
      }

    }
    window.customElements.define(TypioStats.is, TypioStats);

  </script>
</dom-module>
